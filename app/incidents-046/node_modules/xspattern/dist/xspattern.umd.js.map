{"version":3,"file":"xspattern.umd.js","sources":["../src/basic-sets.ts","../src/compiler.ts","../node_modules/prsc/src/parser-combinators.ts","../src/unicode-categories.ts","../src/sets.ts","../src/unicode-blocks.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["import { Codepoint, Predicate } from './types';\n\nexport function singleChar(expected: Codepoint): Predicate {\n\treturn (codepoint) => codepoint === expected;\n}\n\nexport function charRange(first: Codepoint | null, last: Codepoint | null): Predicate {\n\t// It is an error if either of the two singleChars in a charRange is a\n\t// SingleCharNoEsc comprising an unescaped hyphen\n\tif (first === null || last === null) {\n\t\tthrow new Error('unescaped hyphen may not be used as a range endpoint');\n\t}\n\n\t// Inverted range is not explicitly disallowed by the XML Schema 1.1 spec,\n\t// but is forbidden by the XML Schema Part 2: Datatypes Second Edition spec.\n\t// Let's adopt the 1.0 behavior, as the XML Schema test suite seems to agree\n\tif (last < first) {\n\t\tthrow new Error('character range is in the wrong order');\n\t}\n\n\treturn (codepoint) => first <= codepoint && codepoint <= last;\n}\n\nexport function everything(_codepoint: Codepoint): boolean {\n\treturn true;\n}\n\nexport function nothing(): boolean {\n\treturn false;\n}\n\nexport function union(first: Predicate, next: Predicate): Predicate {\n\treturn (codepoint) => first(codepoint) || next(codepoint);\n}\n\nexport const INPUT_START_SENTINEL = -1;\nexport const INPUT_END_SENTINEL = -2;\n","import { Assembler } from 'whynot';\nimport { RegExp, Branch, Piece, Atom } from './ast';\n\ntype RegExpAssembler = Assembler<number, void>;\n\nfunction compileAtom(assembler: RegExpAssembler, atom: Atom): void {\n\tswitch (atom.kind) {\n\t\tcase 'predicate': {\n\t\t\t// Value is a predicate function for some character class\n\t\t\tassembler.test(atom.value);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'regexp':\n\t\t\t// Value is a nested RegExp\n\t\t\tcompileRegExp(assembler, atom.value, false);\n\t\t\treturn;\n\t}\n}\n\nfunction compilePiece(assembler: RegExpAssembler, piece: Piece): void {\n\t// Atom and quantifier\n\tconst [atomAst, { min, max }] = piece;\n\tif (max === null) {\n\t\t// Unbounded repetition\n\t\tif (min > 0) {\n\t\t\tfor (let i = 0; i < min - 1; ++i) {\n\t\t\t\tcompileAtom(assembler, atomAst);\n\t\t\t}\n\t\t\t// Efficient \"1 or more\" loop\n\t\t\tconst start = assembler.program.length;\n\t\t\tcompileAtom(assembler, atomAst);\n\t\t\tconst fork = assembler.jump([start]);\n\t\t\tfork.data.push(assembler.program.length);\n\t\t} else {\n\t\t\t// Optional unbounded loop\n\t\t\tconst start = assembler.program.length;\n\t\t\tconst fork = assembler.jump([]);\n\t\t\t// Match and loop...\n\t\t\tfork.data.push(assembler.program.length);\n\t\t\tcompileAtom(assembler, atomAst);\n\t\t\tassembler.jump([start]);\n\t\t\t// ...or skip\n\t\t\tfork.data.push(assembler.program.length);\n\t\t}\n\t\treturn;\n\t}\n\n\t// Bounded repetition\n\tfor (let i = 0; i < min; ++i) {\n\t\tcompileAtom(assembler, atomAst);\n\t}\n\tfor (let i = min; i < max; ++i) {\n\t\tconst fork = assembler.jump([]);\n\t\t// Match...\n\t\tfork.data.push(assembler.program.length);\n\t\tcompileAtom(assembler, atomAst);\n\t\t// ...or skip\n\t\tfork.data.push(assembler.program.length);\n\t}\n}\n\nfunction compileBranch(assembler: RegExpAssembler, branch: Branch): void {\n\t// Sequence of pieces\n\tbranch.forEach((piece) => {\n\t\tcompilePiece(assembler, piece);\n\t});\n}\n\nexport function compileRegExp(\n\tassembler: RegExpAssembler,\n\tregExp: RegExp,\n\tmatchSubstring: boolean\n): void {\n\tconst start = assembler.program.length;\n\n\t// Disjunction of branches\n\tconst fork = assembler.jump([]);\n\n\t// If we are compiling an XPath-style pattern, add a set of jumps and accepts to add the 'match\n\t// anywhere' behavior at the start.\n\tif (matchSubstring) {\n\t\tfork.data.push(assembler.program.length);\n\t\tassembler.test(() => true);\n\t\tassembler.jump([start]);\n\t}\n\n\t// TODO: I should really export Instruction from whynot...\n\tconst joins: typeof fork[] = [];\n\tregExp.forEach((branch) => {\n\t\tfork.data.push(assembler.program.length);\n\t\tcompileBranch(assembler, branch);\n\t\tjoins.push(assembler.jump([]));\n\t});\n\tjoins.forEach((join) => {\n\t\tjoin.data.push(assembler.program.length);\n\t});\n\n\t// Add a jump and all-accepting test for the 'end' of the program to add the 'match anything'\n\t// behavior at the end.\n\tif (matchSubstring) {\n\t\tconst beforeFork = assembler.program.length;\n\t\tconst forkForEnd = assembler.jump([]);\n\t\tforkForEnd.data.push(assembler.program.length);\n\t\t// Allow everything\n\t\tassembler.test(() => true);\n\t\t// And allow it multiple times\n\t\tassembler.jump([beforeFork]);\n\t\t// Or skip it completely\n\t\tforkForEnd.data.push(assembler.program.length);\n\t}\n}\n","/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\nfunction lengthFromCodePoint(cp: number): number {\n\treturn cp > 0xffff ? 2 : 1;\n}\n\n/**\n * Creates a Parser that skips the next code point if the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * To match a sequence of code points, consider using `codepoints` instead.\n *\n * @public\n *\n * @param isMatch  - callback called with the next codepoint, should return whether that matches\n * @param expected - expected strings to return if the codepoint does not match\n */\nexport function codepoint(\n\tisMatch: (codepoint: number) => boolean,\n\texpected: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp === undefined || !isMatch(cp)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset + lengthFromCodePoint(cp));\n\t};\n}\n\n/**\n * Creates a Parser that skips code points while the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * This acts like `starConsumed(codepoint(isMatch, []))` if expected is not set, or as\n * `plusConsumed(codepoint(isMatch, expected))` if it is, but is much more efficient than either of\n * those combinations.\n *\n * @public\n *\n * @param isMatch  - callback called for each codepoint, should return whether that matches\n * @param expected - expected strings to return if the first codepoint does not match\n */\nexport function codepoints(\n\tisMatch: (codepoint: number) => boolean,\n\texpected?: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst startOffset = offset;\n\t\twhile (true) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!isMatch(cp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += cp > 0xffff ? 2 : 1;\n\t\t}\n\t\tif (expected !== undefined && offset === startOffset) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * Use `recognize` if you need the character that was matched.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(\n\tfirstCodePoint: number,\n\tlastCodePoint: number,\n\texpected?: string[]\n): Parser<void> {\n\treturn codepoint(\n\t\t(cp) => firstCodePoint <= cp && cp <= lastCodePoint,\n\t\texpected || [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]\n\t);\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += lengthFromCodePoint(cp);\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers  - Parsers to attempt to apply\n * @param expected - Overrides the expected value used if none of the inner parsers match\n */\nexport function or<T>(parsers: Parser<T>[], expected?: string[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset && expected === undefined) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\texpected = expected || lastError?.expected || [];\n\t\tif (lastError) {\n\t\t\tlastError.expected = expected;\n\t\t}\n\t\treturn lastError || error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function starConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn (input, offset) => {\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn ok(nextOffset);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached. The parser is required to match at least once, so an initial failure is\n * returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plusConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn then(parser, starConsumed(parser), second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * When using this in combination with `star` or `plus`, consider using `starConsumed` or\n * `plusConsumed` instead for efficiency.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { charRange, nothing, singleChar, union } from './basic-sets';\nimport { Codepoint, Predicate } from './types';\n\nexport const CATEGORIES = [\n\t'Lu',\n\t'Ll',\n\t'Lt',\n\t'Lm',\n\t'Lo',\n\t'Mn',\n\t'Mc',\n\t'Me',\n\t'Nd',\n\t'Nl',\n\t'No',\n\t'Pc',\n\t'Pd',\n\t'Ps',\n\t'Pe',\n\t'Pi',\n\t'Pf',\n\t'Po',\n\t'Zs',\n\t'Zl',\n\t'Zp',\n\t'Sm',\n\t'Sc',\n\t'Sk',\n\t'So',\n\t'Cc',\n\t'Cf',\n\t'Co',\n\t'Cn',\n];\n\ntype UnicodeDataEntry = {\n\tcodepoint: Codepoint;\n\tname: string | null;\n\tcategory: string | null;\n\tcatIndex: number;\n};\n\nfunction* parseUnicodeData(data: string): Iterable<UnicodeDataEntry> {\n\tfor (const line of data.split('\\n')) {\n\t\tconst trimmed = line.trim();\n\t\tif (trimmed === '') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst [codepointHex, name, category] = trimmed.split(';');\n\t\tconst codepoint = parseInt(codepointHex, 16);\n\n\t\tconst catIndex = CATEGORIES.indexOf(category);\n\t\tif (catIndex === -1) {\n\t\t\t// Category is not supported by the parser, so we can ignore it. Currently, this is only\n\t\t\t// Cs (surrogates), which will never match as we consider input as full codepoints only.\n\t\t\tcontinue;\n\t\t}\n\n\t\tyield { codepoint, name, category, catIndex };\n\t}\n}\n\nfunction* withExpandedRanges(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet previousCodepoint = -1;\n\tfor (const entry of entries) {\n\t\tconst isRangeStart = entry.name !== null && entry.name.endsWith(', First>');\n\t\tconst isRangeEnd = entry.name !== null && entry.name.endsWith(', Last>');\n\t\tif (isRangeStart) {\n\t\t\tpreviousCodepoint = entry.codepoint;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isRangeEnd) {\n\t\t\tfor (let codepoint = previousCodepoint; codepoint < entry.codepoint; ++codepoint) {\n\t\t\t\tyield { ...entry, codepoint };\n\t\t\t}\n\t\t}\n\t\tyield entry;\n\t}\n}\n\nfunction* withExpandedGaps(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet previousCodepoint = -1;\n\tfor (const entry of entries) {\n\t\tfor (let codepoint = previousCodepoint + 1; codepoint < entry.codepoint; ++codepoint) {\n\t\t\tyield { codepoint, name: null, category: null, catIndex: -1 };\n\t\t}\n\t\tyield entry;\n\t\tpreviousCodepoint = entry.codepoint;\n\t}\n}\n\ntype AlternationState = 'out' | 'lower' | 'upper';\n\nfunction* withAlternationCategory(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet first: UnicodeDataEntry | null = null;\n\tlet second: UnicodeDataEntry | null = null;\n\tlet state: AlternationState = 'out';\n\tfor (let entry of entries) {\n\t\tswitch (state) {\n\t\t\tcase 'out':\n\t\t\t\t// Start a new sequence?\n\t\t\t\tif (\n\t\t\t\t\tfirst !== null &&\n\t\t\t\t\tsecond !== null &&\n\t\t\t\t\tfirst.category === 'Lu' &&\n\t\t\t\t\tsecond.category === 'Ll' &&\n\t\t\t\t\tentry.category === 'Lu'\n\t\t\t\t) {\n\t\t\t\t\tstate = 'lower';\n\t\t\t\t\tfirst = { ...first, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tsecond = { ...second, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'lower':\n\t\t\t\tif (entry.category === 'Ll') {\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tstate = 'upper';\n\t\t\t\t} else {\n\t\t\t\t\t// If the alternation is broken by a double upper case, reset second to avoid\n\t\t\t\t\t// creating adjacent alternations\n\t\t\t\t\tif (entry.category === 'Lu' && second !== null) {\n\t\t\t\t\t\tsecond = { ...second, category: 'Lu', catIndex: 0 };\n\t\t\t\t\t}\n\t\t\t\t\tstate = 'out';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'upper':\n\t\t\t\tif (entry.category === 'Lu') {\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tstate = 'lower';\n\t\t\t\t} else {\n\t\t\t\t\tstate = 'out';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (first !== null) {\n\t\t\tyield first;\n\t\t}\n\t\tfirst = second;\n\t\tsecond = entry;\n\t}\n\tif (first !== null) {\n\t\tyield first;\n\t}\n\tif (second !== null) {\n\t\tyield second;\n\t}\n}\n\nexport type UnicodeDataRange = { start: number; end: number; catIndex: number };\n\nfunction* asRanges(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataRange> {\n\tlet previousEntry = null;\n\tlet rangeStart = 0;\n\tfor (const entry of entries) {\n\t\tif (previousEntry !== null && entry.catIndex !== previousEntry.catIndex) {\n\t\t\tyield {\n\t\t\t\tstart: rangeStart,\n\t\t\t\tend: previousEntry.codepoint,\n\t\t\t\tcatIndex: previousEntry.catIndex,\n\t\t\t};\n\t\t\trangeStart = entry.codepoint;\n\t\t}\n\t\tpreviousEntry = entry;\n\t}\n\n\tif (previousEntry !== null) {\n\t\tyield { start: rangeStart, end: previousEntry.codepoint, catIndex: previousEntry.catIndex };\n\t}\n}\n\nconst base64ByNumber = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction* encodeRange(range: UnicodeDataRange): Iterable<string> {\n\t// Length 0 never happens, so let's not waste the A and subtract one in advance\n\tconst length = range.end - range.start;\n\tlet catIndex = range.catIndex + 2;\n\tlet encodedLength: string;\n\tif (length < base64ByNumber.length) {\n\t\tencodedLength = base64ByNumber.charAt(length);\n\t} else {\n\t\tcatIndex |= 0b100000;\n\t\tconst mask = 0b111111;\n\t\tencodedLength = [\n\t\t\tlength & mask,\n\t\t\t(length >> 6) & mask,\n\t\t\t(length >> 12) & mask,\n\t\t\t(length >> 18) & mask,\n\t\t]\n\t\t\t.map((n) => base64ByNumber.charAt(n))\n\t\t\t.join('');\n\t}\n\t// category\n\tyield base64ByNumber.charAt(catIndex);\n\t// length\n\tyield encodedLength;\n}\n\nexport function* encode(ranges: Iterable<UnicodeDataRange>): Iterable<string> {\n\tfor (const range of ranges) {\n\t\tyield* encodeRange(range);\n\t}\n}\n\nexport function packCategories(data: string): string {\n\tconst codepoints = withAlternationCategory(\n\t\twithExpandedGaps(withExpandedRanges(parseUnicodeData(data)))\n\t);\n\tconst ranges = asRanges(codepoints);\n\tconst mapping = [...encode(ranges)].join('');\n\n\treturn mapping;\n}\n\nconst numberByBase64: { [key: string]: number } = {};\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach((c, i) => {\n\tnumberByBase64[c] = i;\n});\n\nexport function unpackCategories(packed: string): Map<string, Predicate> {\n\tconst predicateByCategory: Map<string, Predicate> = new Map();\n\tconst encodedMapping = packed.split('');\n\tconst partsByCatIndex: Predicate[][] = CATEGORIES.map(() => []);\n\tlet first = 0;\n\tlet i = 0;\n\twhile (i < encodedMapping.length) {\n\t\tconst encodedCatIndex = numberByBase64[encodedMapping[i]];\n\t\tconst catIndex = (encodedCatIndex & 0b11111) - 2;\n\t\tlet length = 1 + numberByBase64[encodedMapping[i + 1]];\n\t\tif (encodedCatIndex & 0b100000) {\n\t\t\tlength += numberByBase64[encodedMapping[i + 2]] << 6;\n\t\t\tlength += numberByBase64[encodedMapping[i + 3]] << 12;\n\t\t\tlength += numberByBase64[encodedMapping[i + 4]] << 18;\n\t\t\ti += 5;\n\t\t} else {\n\t\t\ti += 2;\n\t\t}\n\t\tswitch (catIndex) {\n\t\t\tcase -2: {\n\t\t\t\tlet actualCatIndex = 0;\n\t\t\t\tfor (let codepoint = first; codepoint < first + length; ++codepoint) {\n\t\t\t\t\tconst parts = partsByCatIndex[actualCatIndex];\n\t\t\t\t\tparts.push(singleChar(codepoint));\n\t\t\t\t\tactualCatIndex = (actualCatIndex + 1) % 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase -1:\n\t\t\t\t// Gap, ignore\n\t\t\t\tbreak;\n\n\t\t\tdefault: {\n\t\t\t\tconst parts = partsByCatIndex[catIndex];\n\t\t\t\tif (length === 1) {\n\t\t\t\t\tparts.push(singleChar(first));\n\t\t\t\t} else {\n\t\t\t\t\tparts.push(charRange(first, first + length - 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfirst += length;\n\t}\n\tconst partsByPrefix: Map<string, Predicate[]> = new Map();\n\tCATEGORIES.forEach((category, i) => {\n\t\tconst predicate = partsByCatIndex[i].reduce(union, nothing);\n\t\tpredicateByCategory.set(category, predicate);\n\t\tconst prefix = category.charAt(0);\n\t\tconst parts = partsByPrefix.get(prefix) || [];\n\t\tpartsByPrefix.set(prefix, parts);\n\t\tparts.push(predicate);\n\t});\n\tpartsByPrefix.forEach((parts, prefix) => {\n\t\tpredicateByCategory.set(prefix, parts.reduce(union, nothing));\n\t});\n\treturn predicateByCategory;\n}\n","import {\n\tcharRange,\n\teverything,\n\tINPUT_END_SENTINEL,\n\tINPUT_START_SENTINEL,\n\tsingleChar,\n\tunion,\n} from './basic-sets';\nimport { lengths as blockLengths, names as blockNames } from './generated/blocks.json';\nimport categories from './generated/categories.json';\nimport { Codepoint, Predicate } from './types';\nimport { unpackBlocks } from './unicode-blocks';\nimport { unpackCategories } from './unicode-categories';\n\nexport { charRange, singleChar, union } from './basic-sets';\n\nexport function asCodepoint(char: string): Codepoint {\n\treturn char.codePointAt(0)!;\n}\n\nconst sentinel: Predicate = (codepoint) =>\n\tcodepoint === INPUT_START_SENTINEL || codepoint === INPUT_END_SENTINEL;\n\nexport function complement(predicate: Predicate): Predicate {\n\treturn (codepoint) => !sentinel(codepoint) && !predicate(codepoint);\n}\n\nexport function difference(predicate: Predicate, except: Predicate | null): Predicate {\n\tif (except === null) {\n\t\treturn predicate;\n\t}\n\treturn (codepoint) => predicate(codepoint) && !except(codepoint);\n}\n\nconst predicateByNormalizedBlockId: Map<string, Predicate> = unpackBlocks(blockNames, blockLengths);\nconst predicateByCategory: Map<string, Predicate> = unpackCategories(categories);\n\nexport function unicodeBlock(identifier: string, acceptUnknownBlocks: boolean): Predicate {\n\t// The matching engine is not required to normalize the block identifier in the regexp\n\tconst predicate = predicateByNormalizedBlockId.get(identifier);\n\tif (predicate === undefined) {\n\t\tif (acceptUnknownBlocks) {\n\t\t\t// Unknown blocks should match every character\n\t\t\treturn everything;\n\t\t}\n\n\t\tthrow new Error(`The unicode block identifier \"${identifier}\" is not known.`);\n\t}\n\treturn predicate;\n}\n\nexport function unicodeCategory(identifier: string): Predicate {\n\tconst predicate = predicateByCategory.get(identifier);\n\t// If is unreachable, as the parser will never match unsupported identifiers\n\t/* istanbul ignore if */\n\tif (predicate == undefined) {\n\t\tthrow new Error(`${identifier} is not a valid unicode category`);\n\t}\n\treturn predicate;\n}\n\nfunction whitespace(codepoint: Codepoint): boolean {\n\t// space, tab, newline, carriage return\n\treturn codepoint === 0x20 || codepoint === 0x9 || codepoint === 0xa || codepoint === 0xd;\n}\n\n// From XML 1.1\nconst nameStartChar = [\n\tsingleChar(asCodepoint(':')),\n\tcharRange(asCodepoint('A'), asCodepoint('Z')),\n\tsingleChar(asCodepoint('_')),\n\tcharRange(asCodepoint('a'), asCodepoint('z')),\n\tcharRange(0xc0, 0xd6),\n\tcharRange(0xd8, 0xf6),\n\tcharRange(0xc0, 0xd6),\n\tcharRange(0xd8, 0xf6),\n\tcharRange(0xf8, 0x2ff),\n\tcharRange(0x370, 0x37d),\n\tcharRange(0x37f, 0x1fff),\n\tcharRange(0x200c, 0x200d),\n\tcharRange(0x2070, 0x218f),\n\tcharRange(0x2c00, 0x2fef),\n\tcharRange(0x3001, 0xd7ff),\n\tcharRange(0xf900, 0xfdcf),\n\tcharRange(0xfdf0, 0xfffd),\n\tcharRange(0x10000, 0xeffff),\n].reduce(union);\n\nconst nameChar = [\n\tnameStartChar,\n\tsingleChar(asCodepoint('-')),\n\tsingleChar(asCodepoint('.')),\n\tcharRange(asCodepoint('0'), asCodepoint('9')),\n\tsingleChar(0xb7),\n\tcharRange(0x300, 0x36f),\n\tcharRange(0x203f, 0x2040),\n].reduce(union);\n\nconst digit = predicateByCategory.get('Nd')!;\nconst notDigit = complement(digit);\nconst wordChar = difference(\n\tcharRange(0x0000, 0x10ffff),\n\t[\n\t\tpredicateByCategory.get('P')!,\n\t\tpredicateByCategory.get('Z')!,\n\t\tpredicateByCategory.get('C')!,\n\t].reduce(union)\n);\nconst notWordChar = complement(wordChar);\n\nexport function wildcard(codepoint: Codepoint): boolean {\n\t// Anything except newline, carriage return and the start / end sentinels\n\treturn codepoint !== 0xa && codepoint !== 0xd && !sentinel(codepoint);\n}\n\nexport const multiChar = {\n\ts: whitespace,\n\tS: complement(whitespace),\n\ti: nameStartChar,\n\tI: complement(nameStartChar),\n\tc: nameChar,\n\tC: complement(nameChar),\n\td: digit,\n\tD: notDigit,\n\tw: wordChar,\n\tW: notWordChar,\n};\n","import { charRange, union } from './basic-sets';\nimport { Codepoint, Predicate } from './types';\n\nexport type PackedBlocks = { names: (string | null)[]; lengths: number[] };\n\n// For Unicode 3.1 compatibility\nconst COMPATIBILITY_ALIASES: { [key: string]: string | undefined } = {\n\tGreekandCoptic: 'Greek',\n\tCombiningDiacriticalMarksforSymbols: 'CombiningMarksforSymbols',\n\tPrivateUseArea: 'PrivateUse',\n\t'SupplementaryPrivateUseArea-A': 'PrivateUse',\n\t'SupplementaryPrivateUseArea-B': 'PrivateUse',\n};\n\nexport function packBlocks(data: string): PackedBlocks {\n\tlet last = -1;\n\tconst names: (string | null)[] = [];\n\tconst lengths: number[] = [];\n\tdata.split('\\n').forEach((line) => {\n\t\tconst trimmed = line.trim();\n\t\tif (trimmed === '' || trimmed.startsWith('#')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [range, name] = trimmed.split(';');\n\t\tconst [startHex, endHex] = range.split('..');\n\t\tconst firstCodepoint = parseInt(startHex, 16);\n\t\tconst lastCodepoint = parseInt(endHex, 16);\n\t\tconst normalizedName = name.replace(/\\s/g, '');\n\t\tconst alias = COMPATIBILITY_ALIASES[normalizedName];\n\n\t\tif (firstCodepoint !== last + 1) {\n\t\t\t// Gap between blocks\n\t\t\tnames.push(null);\n\t\t\tlengths.push(firstCodepoint - last - 1);\n\t\t}\n\t\tnames.push(alias ? normalizedName + '|' + alias : normalizedName);\n\t\tlengths.push(lastCodepoint - firstCodepoint + 1);\n\t\tlast = lastCodepoint;\n\t});\n\n\treturn { names, lengths };\n}\n\nexport function unpackBlocks(\n\tnames: PackedBlocks['names'],\n\tlengths: PackedBlocks['lengths']\n): Map<string, Predicate> {\n\tconst predicateByNormalizedBlockId: Map<string, Predicate> = new Map();\n\tlet first: Codepoint = 0;\n\tnames.forEach((name: string | null, index: number) => {\n\t\tconst length = lengths[index];\n\t\tif (name !== null) {\n\t\t\tname.split('|').forEach((name) => {\n\t\t\t\tconst existing = predicateByNormalizedBlockId.get(name);\n\t\t\t\tconst predicate = charRange(first, first + length - 1);\n\t\t\t\tpredicateByNormalizedBlockId.set(\n\t\t\t\t\tname,\n\t\t\t\t\texisting ? union(existing, predicate) : predicate\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tfirst += length;\n\t});\n\treturn predicateByNormalizedBlockId;\n}\n","import {\n\tcomplete,\n\tcut,\n\tdelimited,\n\terror,\n\tfilter,\n\tfollowed,\n\tmap,\n\tnot,\n\tokWithValue,\n\toptional,\n\tor,\n\tParser,\n\tParseResult,\n\tpeek,\n\tplus,\n\tpreceded,\n\trecognize,\n\tstar,\n\tthen,\n\ttoken,\n} from 'prsc';\nimport { Atom, Branch, Piece, Quantifier, RegExp } from './ast';\nimport { INPUT_END_SENTINEL, INPUT_START_SENTINEL } from './basic-sets';\nimport {\n\tasCodepoint,\n\tcharRange as charRangePredicate,\n\tcomplement,\n\tdifference,\n\tmultiChar,\n\tsingleChar as singleCharPredicate,\n\tunicodeBlock,\n\tunicodeCategory,\n\tunion,\n\twildcard,\n} from './sets';\nimport { Codepoint, Predicate } from './types';\n\n// Tokens\n\nconst ASTERISK = token('*');\nconst BACKSLASH = token('\\\\');\nconst BRACE_OPEN = token('{');\nconst BRACE_CLOSE = token('}');\nconst BRACKET_OPEN = token('[');\nconst BRACKET_CLOSE = token(']');\nconst CARET = token('^');\nconst DOLLAR = token('$');\nconst COMMA = token(',');\nconst HYPHEN = token('-');\nconst PARENTHESIS_OPEN = token('(');\nconst PARENTHESIS_CLOSE = token(')');\nconst PERIOD = token('.');\nconst PIPE = token('|');\nconst PLUS = token('+');\nconst QUESTION_MARK = token('?');\nconst SUBTRACT_MARKER = token('-[');\n\nconst ZERO_CODE_POINT = asCodepoint('0');\n\nexport function generateParser(options: { language: string }): (input: string) => RegExp {\n\tfunction asSetOfCodepoints(chars: string): Set<Codepoint> {\n\t\treturn new Set(chars.split('').map((c) => asCodepoint(c)));\n\t}\n\n\tfunction codepoint(input: string, offset: number): ParseResult<Codepoint> {\n\t\tconst codepoint = input.codePointAt(offset);\n\t\tif (codepoint === undefined) {\n\t\t\treturn error(offset, ['any character']);\n\t\t}\n\t\treturn okWithValue(offset + String.fromCodePoint(codepoint).length, codepoint);\n\t}\n\n\t// Single Character Escape\n\n\tconst SingleCharEsc: Parser<Codepoint> =\n\t\toptions.language === 'xpath'\n\t\t\t? preceded(\n\t\t\t\t\tBACKSLASH,\n\t\t\t\t\tor([\n\t\t\t\t\t\tmap(token('n'), () => 0xa),\n\t\t\t\t\t\tmap(token('r'), () => 0xd),\n\t\t\t\t\t\tmap(token('t'), () => 0x9),\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t\tBACKSLASH,\n\t\t\t\t\t\t\t\tPIPE,\n\t\t\t\t\t\t\t\tPERIOD,\n\t\t\t\t\t\t\t\tHYPHEN,\n\t\t\t\t\t\t\t\tCARET,\n\t\t\t\t\t\t\t\tQUESTION_MARK,\n\t\t\t\t\t\t\t\tASTERISK,\n\t\t\t\t\t\t\t\tPLUS,\n\t\t\t\t\t\t\t\tBRACE_OPEN,\n\t\t\t\t\t\t\t\tBRACE_CLOSE,\n\t\t\t\t\t\t\t\tDOLLAR,\n\t\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\t\tBRACKET_OPEN,\n\t\t\t\t\t\t\t\tBRACKET_CLOSE,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t(c) => asCodepoint(c)\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t  )\n\t\t\t: preceded(\n\t\t\t\t\tBACKSLASH,\n\t\t\t\t\tor([\n\t\t\t\t\t\tmap(token('n'), () => 0xa),\n\t\t\t\t\t\tmap(token('r'), () => 0xd),\n\t\t\t\t\t\tmap(token('t'), () => 0x9),\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t\tBACKSLASH,\n\t\t\t\t\t\t\t\tPIPE,\n\t\t\t\t\t\t\t\tPERIOD,\n\t\t\t\t\t\t\t\tHYPHEN,\n\t\t\t\t\t\t\t\tCARET,\n\t\t\t\t\t\t\t\tQUESTION_MARK,\n\t\t\t\t\t\t\t\tASTERISK,\n\t\t\t\t\t\t\t\tPLUS,\n\t\t\t\t\t\t\t\tBRACE_OPEN,\n\t\t\t\t\t\t\t\tBRACE_CLOSE,\n\t\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\t\tBRACKET_OPEN,\n\t\t\t\t\t\t\t\tBRACKET_CLOSE,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t(c) => asCodepoint(c)\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t  );\n\n\t// Categories\n\n\tfunction categoryIdentifier(primary: string, secondaries: string): Parser<Predicate> {\n\t\tconst secondaryChars = asSetOfCodepoints(secondaries);\n\t\treturn then(\n\t\t\ttoken(primary),\n\t\t\toptional(\n\t\t\t\tfilter(\n\t\t\t\t\tcodepoint,\n\t\t\t\t\t(codepoint) => secondaryChars.has(codepoint),\n\t\t\t\t\tsecondaries.split('')\n\t\t\t\t)\n\t\t\t),\n\t\t\t(p, s) => unicodeCategory(s === null ? p : p + String.fromCodePoint(s))\n\t\t);\n\t}\n\n\tconst Letters = categoryIdentifier('L', 'ultmo');\n\tconst Marks = categoryIdentifier('M', 'nce');\n\tconst Numbers = categoryIdentifier('N', 'dlo');\n\tconst Punctuation = categoryIdentifier('P', 'cdseifo');\n\tconst Separators = categoryIdentifier('Z', 'slp');\n\tconst Symbols = categoryIdentifier('S', 'mcko');\n\tconst Others = categoryIdentifier('C', 'cfon');\n\n\tconst IsCategory: Parser<Predicate> = or([\n\t\tLetters,\n\t\tMarks,\n\t\tNumbers,\n\t\tPunctuation,\n\t\tSeparators,\n\t\tSymbols,\n\t\tOthers,\n\t]);\n\n\t// Block Escape\n\n\tconst isBlockIdentifierChar: Predicate = [\n\t\tcharRangePredicate(asCodepoint('a'), asCodepoint('z')),\n\t\tcharRangePredicate(asCodepoint('A'), asCodepoint('Z')),\n\t\tcharRangePredicate(asCodepoint('0'), asCodepoint('9')),\n\t\tsingleCharPredicate(0x2d),\n\t].reduce(union);\n\n\tconst IsBlock: Parser<Predicate> = map(\n\t\tpreceded(\n\t\t\ttoken('Is'),\n\t\t\trecognize(plus(filter(codepoint, isBlockIdentifierChar, ['block identifier'])))\n\t\t),\n\t\t(identifier) => unicodeBlock(identifier, options.language !== 'xpath')\n\t);\n\n\t// Category Escape\n\n\tconst charProp: Parser<Predicate> = or([IsCategory, IsBlock]);\n\n\tconst catEsc: Parser<Predicate> = delimited(token('\\\\p{'), charProp, BRACE_CLOSE, true);\n\n\tconst complEsc: Parser<Predicate> = map(\n\t\tdelimited(token('\\\\P{'), charProp, BRACE_CLOSE, true),\n\t\tcomplement\n\t);\n\n\t// Multi-Character Escape\n\n\tconst MultiCharEsc: Parser<Predicate> = preceded(\n\t\tBACKSLASH,\n\t\tmap(\n\t\t\tor('sSiIcCdDwW'.split('').map((c) => token(c))) as Parser<keyof typeof multiChar>,\n\t\t\t(c) => multiChar[c]\n\t\t)\n\t);\n\n\tconst WildcardEsc: Parser<Predicate> = map(PERIOD, () => wildcard);\n\n\t// Character Class Escape\n\n\tconst charClassEsc: Parser<Predicate> = or([MultiCharEsc, catEsc, complEsc]);\n\n\t// Single Unescaped Character\n\n\tconst notSingleCharNoEsc = asSetOfCodepoints('\\\\[]');\n\n\tconst SingleCharNoEsc: Parser<Codepoint> = filter(\n\t\tcodepoint,\n\t\t(codepoint) => !notSingleCharNoEsc.has(codepoint),\n\t\t['unescaped character']\n\t);\n\n\tconst singleChar: Parser<Codepoint> = or([SingleCharEsc, SingleCharNoEsc]);\n\n\t// Character Range\n\n\tconst singleCharHyphenAsNull: Parser<Codepoint | null> = or([\n\t\tmap(HYPHEN, () => null),\n\t\tsingleChar,\n\t]);\n\n\tconst charRange: Parser<Predicate> = then(\n\t\tsingleCharHyphenAsNull,\n\t\tpreceded(HYPHEN, singleCharHyphenAsNull),\n\t\tcharRangePredicate\n\t);\n\n\t// Character Group Part\n\n\tfunction cons<T>(first: T, rest: T[] | null) {\n\t\treturn [first].concat(rest || []);\n\t}\n\n\tconst assertEndOfCharGroup: Parser<null> = map(\n\t\tpeek(or([BRACKET_CLOSE, SUBTRACT_MARKER])),\n\t\t() => null\n\t);\n\n\tconst hyphenCodepoint = asCodepoint('-');\n\tconst singleCharHyphenWithHyphenRules: Parser<Codepoint> = map(\n\t\tfollowed(followed(HYPHEN, not(BRACKET_OPEN, ['not ['])), assertEndOfCharGroup),\n\t\t() => hyphenCodepoint\n\t);\n\n\tconst singleCharWithHyphenRules: Parser<Codepoint> = or([\n\t\tsingleCharHyphenWithHyphenRules,\n\t\tpreceded(not(HYPHEN, ['not -']), singleChar),\n\t]);\n\n\tconst charGroupPartsWithHyphenRules: Parser<Predicate[]> = or([\n\t\tthen(\n\t\t\tmap(singleCharWithHyphenRules, singleCharPredicate),\n\t\t\tor([charGroupPartsWithHyphenRulesIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t\tthen(\n\t\t\tor([charRange, charClassEsc]),\n\t\t\tor([charGroupPartsIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t]);\n\n\tfunction charGroupPartsWithHyphenRulesIndirect(\n\t\tinput: string,\n\t\toffset: number\n\t): ParseResult<Predicate[]> {\n\t\treturn charGroupPartsWithHyphenRules(input, offset);\n\t}\n\n\tconst charGroupParts: Parser<Predicate[]> = or([\n\t\tthen(\n\t\t\tmap(singleChar, singleCharPredicate),\n\t\t\tor([charGroupPartsWithHyphenRules, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t\tthen(\n\t\t\tor([charRange, charClassEsc]),\n\t\t\tor([charGroupPartsIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t]);\n\n\tfunction charGroupPartsIndirect(input: string, offset: number): ParseResult<Predicate[]> {\n\t\treturn charGroupParts(input, offset);\n\t}\n\n\t// Positive Character Group\n\n\tconst posCharGroup: Parser<Predicate> = map(charGroupParts, (parts) => parts.reduce(union));\n\n\t// Negative Character Group\n\n\tconst negCharGroup: Parser<Predicate> = map(preceded(CARET, posCharGroup), complement);\n\n\t// Character Group\n\n\tconst charGroup: Parser<Predicate> = then(\n\t\tor([preceded(not(CARET, ['not ^']), posCharGroup), negCharGroup]),\n\t\toptional(preceded(HYPHEN, charClassExprIndirect)),\n\t\tdifference\n\t);\n\n\t// Character Class Expression\n\n\tconst charClassExpr: Parser<Predicate> = delimited(\n\t\tBRACKET_OPEN,\n\t\tcharGroup,\n\t\tBRACKET_CLOSE,\n\t\ttrue\n\t);\n\n\tfunction charClassExprIndirect(input: string, offset: number): ParseResult<Predicate> {\n\t\treturn charClassExpr(input, offset);\n\t}\n\n\t// Character Class\n\n\tconst charClass: Parser<Predicate> =\n\t\toptions.language === 'xpath'\n\t\t\t? or([\n\t\t\t\t\tmap(SingleCharEsc, singleCharPredicate),\n\t\t\t\t\tcharClassEsc,\n\t\t\t\t\tcharClassExpr,\n\t\t\t\t\tWildcardEsc,\n\t\t\t\t\tmap(CARET, () => (c: Codepoint) => c === INPUT_START_SENTINEL),\n\t\t\t\t\tmap(DOLLAR, () => (c: Codepoint) => c === INPUT_END_SENTINEL),\n\t\t\t  ])\n\t\t\t: or([\n\t\t\t\t\tmap(SingleCharEsc, singleCharPredicate),\n\t\t\t\t\tcharClassEsc,\n\t\t\t\t\tcharClassExpr,\n\t\t\t\t\tWildcardEsc,\n\t\t\t  ]);\n\n\t// Normal Character\n\n\tconst metachars =\n\t\toptions.language === 'xpath'\n\t\t\t? asSetOfCodepoints('.\\\\?*+{}()|^$[]')\n\t\t\t: asSetOfCodepoints('.\\\\?*+{}()|[]');\n\tconst NormalChar: Parser<Codepoint> = filter(\n\t\tcodepoint,\n\t\t(codepoint) => !metachars.has(codepoint),\n\t\t['NormalChar']\n\t);\n\n\t// BackReference (XPath only)\n\tconst backReference: Parser<never> = map(\n\t\tpreceded(\n\t\t\tBACKSLASH,\n\t\t\tthen(\n\t\t\t\tmap(\n\t\t\t\t\tfilter(codepoint, charRangePredicate(asCodepoint('1'), asCodepoint('9')), [\n\t\t\t\t\t\t'digit',\n\t\t\t\t\t]),\n\t\t\t\t\t(codepoint) => codepoint - ZERO_CODE_POINT\n\t\t\t\t),\n\t\t\t\tstar(\n\t\t\t\t\tmap(\n\t\t\t\t\t\tfilter(codepoint, charRangePredicate(ZERO_CODE_POINT, asCodepoint('9')), [\n\t\t\t\t\t\t\t'digit',\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t(codepoint) => codepoint - ZERO_CODE_POINT\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t(firstDigit, restDigits) => {\n\t\t\t\t\trestDigits.reduce((sum, digit) => sum * 10 + digit, firstDigit);\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\t(_backReferenceNumber) => {\n\t\t\tthrow new Error('Backreferences in XPath patterns are not yet implemented.');\n\t\t}\n\t);\n\n\t// Atom\n\n\tconst atom: Parser<Atom> =\n\t\toptions.language === 'xpath'\n\t\t\t? or<Atom>([\n\t\t\t\t\tmap(NormalChar, (codepoint) => ({\n\t\t\t\t\t\tkind: 'predicate',\n\t\t\t\t\t\tvalue: singleCharPredicate(codepoint),\n\t\t\t\t\t})),\n\t\t\t\t\tmap(charClass, (predicate) => ({ kind: 'predicate', value: predicate })),\n\t\t\t\t\tmap(\n\t\t\t\t\t\tdelimited(\n\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\tpreceded(optional(token('?:')), regexpIndirect),\n\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t),\n\t\t\t\t\t\t(regexp) => ({\n\t\t\t\t\t\t\tkind: 'regexp',\n\t\t\t\t\t\t\tvalue: regexp,\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t\t\tbackReference,\n\t\t\t  ])\n\t\t\t: or<Atom>([\n\t\t\t\t\tmap(NormalChar, (codepoint) => ({\n\t\t\t\t\t\tkind: 'predicate',\n\t\t\t\t\t\tvalue: singleCharPredicate(codepoint),\n\t\t\t\t\t})),\n\t\t\t\t\tmap(charClass, (predicate) => ({ kind: 'predicate', value: predicate })),\n\t\t\t\t\tmap(\n\t\t\t\t\t\tdelimited(PARENTHESIS_OPEN, regexpIndirect, PARENTHESIS_CLOSE, true),\n\t\t\t\t\t\t(regexp) => ({\n\t\t\t\t\t\t\tkind: 'regexp',\n\t\t\t\t\t\t\tvalue: regexp,\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t  ]);\n\n\t// Quantifier\n\n\tconst isDigit = charRangePredicate(ZERO_CODE_POINT, asCodepoint('9'));\n\tconst QuantExact: Parser<number> = map(\n\t\tplus(\n\t\t\tmap(filter(codepoint, isDigit, ['digit']), (codepoint) => codepoint - ZERO_CODE_POINT)\n\t\t),\n\t\t(digits) => digits.reduce((num, digit) => num * 10 + digit)\n\t);\n\n\tconst quantRange: Parser<Quantifier> = then(\n\t\tQuantExact,\n\t\tpreceded(COMMA, QuantExact),\n\t\t(min, max) => {\n\t\t\tif (max < min) {\n\t\t\t\tthrow new Error('quantifier range is in the wrong order');\n\t\t\t}\n\t\t\treturn { min, max };\n\t\t}\n\t);\n\n\tconst quantMin: Parser<Quantifier> = then(QuantExact, COMMA, (min) => ({ min, max: null }));\n\n\tconst quantity: Parser<Quantifier> = or([\n\t\tquantRange,\n\t\tquantMin,\n\t\tmap(QuantExact, (q) => ({ min: q, max: q })),\n\t]);\n\n\tconst quantifier: Parser<Quantifier> =\n\t\toptions.language === 'xpath'\n\t\t\t? then(\n\t\t\t\t\tor<Quantifier>([\n\t\t\t\t\t\tmap(QUESTION_MARK, () => ({ min: 0, max: 1 })),\n\t\t\t\t\t\tmap(ASTERISK, () => ({ min: 0, max: null })),\n\t\t\t\t\t\tmap(PLUS, () => ({ min: 1, max: null })),\n\t\t\t\t\t\tdelimited(BRACE_OPEN, quantity, BRACE_CLOSE, true),\n\t\t\t\t\t]),\n\t\t\t\t\toptional(QUESTION_MARK),\n\t\t\t\t\t(quantifier, _isReluctant) => quantifier\n\t\t\t  )\n\t\t\t: or<Quantifier>([\n\t\t\t\t\tmap(QUESTION_MARK, () => ({ min: 0, max: 1 })),\n\t\t\t\t\tmap(ASTERISK, () => ({ min: 0, max: null })),\n\t\t\t\t\tmap(PLUS, () => ({ min: 1, max: null })),\n\t\t\t\t\tdelimited(BRACE_OPEN, quantity, BRACE_CLOSE, true),\n\t\t\t  ]);\n\n\t// Piece\n\n\tconst piece: Parser<Piece> = then(\n\t\tatom,\n\t\tmap(optional(quantifier), (q) => (q === null ? { min: 1, max: 1 } : q)),\n\t\t(a, q) => [a, q]\n\t);\n\n\t// Branch\n\n\tconst branch: Parser<Branch> = star(piece);\n\n\t// Regular Expression - with wrapper because of recursion\n\n\tconst regexp: Parser<RegExp> = then(branch, star(preceded(PIPE, cut(branch))), (b, bs) =>\n\t\t[b].concat(bs)\n\t);\n\n\tfunction regexpIndirect(input: string, offset: number): ParseResult<RegExp> {\n\t\treturn regexp(input, offset);\n\t}\n\n\tfunction throwParseError(input: string, offset: number, expected: string[]): never {\n\t\tconst quoted = expected.map((str) => `\"${str}\"`);\n\t\tthrow new Error(\n\t\t\t`Error parsing pattern \"${input}\" at offset ${offset}: expected ${\n\t\t\t\tquoted.length > 1 ? 'one of ' + quoted.join(', ') : quoted[0]\n\t\t\t} but found \"${input.slice(offset, offset + 1)}\"`\n\t\t);\n\t}\n\n\tconst completeRegexp: Parser<RegExp> = complete(regexp);\n\n\treturn function parse(input: string): RegExp {\n\t\tlet res: ParseResult<RegExp>;\n\t\ttry {\n\t\t\tres = completeRegexp(input, 0);\n\t\t} catch (error) {\n\t\t\t// Generic error\n\t\t\tthrow new Error(\n\t\t\t\t`Error parsing pattern \"${input}\": ${\n\t\t\t\t\terror instanceof Error ? error.message : error\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t\tif (!res.success) {\n\t\t\treturn throwParseError(input, res.offset, res.expected);\n\t\t}\n\n\t\treturn res.value;\n\t};\n}\n","import { compileVM } from 'whynot';\nimport { INPUT_END_SENTINEL, INPUT_START_SENTINEL } from './basic-sets';\nimport { compileRegExp } from './compiler';\nimport { generateParser } from './parser';\n\nfunction toCodePoints(str: string): number[] {\n\treturn [...str].map((c) => c.codePointAt(0)!);\n}\n\n/**\n * A function used to validate strings against the pattern it represents. Accepts a single string\n * and returns a boolean indicating whether it matches the pattern.\n *\n * @public\n */\nexport type MatchFn = (str: string) => boolean;\n\n/**\n * Options to control pattern compilation.\n *\n * Currently, only a language option is supported, defaulting to 'xsd'. Set this to 'xpath' to\n * compile the pattern with XPath syntax and semantics. Note that not all XPath-specific features\n * are currently supported. See https://github.com/bwrrp/xspattern.js/issues/9 for details.\n *\n * @public\n */\nexport type Options = {\n\tlanguage: 'xsd' | 'xpath';\n};\n\n/**\n * Compiles the given pattern into a matching function. The returned function accepts a single\n * string and returns true iff the pattern matches it.\n *\n * @public\n *\n * @param pattern - Pattern to compile\n * @param options - Additional options for the compiler\n *\n * @returns a matcher function for the given pattern\n */\nexport function compile(pattern: string, options: Options = { language: 'xsd' }): MatchFn {\n\tconst ast = generateParser(options)(pattern);\n\n\tconst vm = compileVM<number>((assembler) => {\n\t\tcompileRegExp(assembler, ast, options.language === 'xpath');\n\t\tassembler.accept();\n\t});\n\n\treturn function match(str: string): boolean {\n\t\tconst codepoints =\n\t\t\toptions.language === 'xpath'\n\t\t\t\t? [INPUT_START_SENTINEL, ...toCodePoints(str), INPUT_END_SENTINEL]\n\t\t\t\t: toCodePoints(str);\n\t\treturn vm.execute(codepoints).success;\n\t};\n}\n"],"names":["singleChar","expected","codepoint","charRange","first","last","Error","everything","_codepoint","nothing","union","next","compileAtom","assembler","atom","kind","test","value","compileRegExp","compileBranch","branch","forEach","piece","atomAst","min","max","i","fork","jump","data","push","program","length","start","compilePiece","regExp","matchSubstring","joins","join","beforeFork","forkForEnd","okWithValue","offset","success","ok","error","fatal","token","input","offsetAfter","slice","map","parser","res","filter","or","parsers","lastError","undefined","concat","optional","star","ts","nextOffset","v","then","parser1","parser2","r1","r2","plus","vs","x","y","second","preceded","before","followed","after","delimited","open","inner","close","cutAfterOpen","cut","not","end","CATEGORIES","numberByBase64","asCodepoint","char","codePointAt","split","c","sentinel","complement","predicate","difference","except","predicateByNormalizedBlockId","names","lengths","Map","name","index","existing","get","set","unpackBlocks","predicateByCategory","packed","encodedMapping","partsByCatIndex","encodedCatIndex","catIndex","actualCatIndex","parts","partsByPrefix","category","reduce","prefix","charAt","unpackCategories","whitespace","nameStartChar","nameChar","digit","notDigit","wordChar","notWordChar","wildcard","multiChar","s","S","I","C","d","D","w","W","ASTERISK","BACKSLASH","BRACE_OPEN","BRACE_CLOSE","BRACKET_OPEN","BRACKET_CLOSE","CARET","DOLLAR","COMMA","HYPHEN","PARENTHESIS_OPEN","PARENTHESIS_CLOSE","PERIOD","PIPE","PLUS","QUESTION_MARK","SUBTRACT_MARKER","ZERO_CODE_POINT","generateParser","options","asSetOfCodepoints","chars","Set","String","fromCodePoint","SingleCharEsc","language","categoryIdentifier","primary","secondaries","secondaryChars","has","p","identifier","unicodeCategory","IsCategory","isBlockIdentifierChar","charRangePredicate","singleCharPredicate","charProp","recognize","acceptUnknownBlocks","unicodeBlock","catEsc","complEsc","MultiCharEsc","WildcardEsc","charClassEsc","notSingleCharNoEsc","singleCharHyphenAsNull","cons","rest","assertEndOfCharGroup","peek","hyphenCodepoint","singleCharWithHyphenRules","charGroupPartsWithHyphenRules","charGroupPartsIndirect","charGroupParts","posCharGroup","negCharGroup","charGroup","charClassExpr","charClass","metachars","NormalChar","backReference","firstDigit","restDigits","sum","_backReferenceNumber","regexpIndirect","regexp","QuantExact","digits","num","quantity","q","quantifier","_isReluctant","a","b","bs","completeRegexp","complete","message","quoted","str","throwParseError","toCodePoints","pattern","ast","vm","compileVM","accept","codepoints","execute"],"mappings":"uRAEM,SAAUA,EAAWC,GAC1B,OAAQC,GAAcA,IAAcD,EAGrB,SAAAE,EAAUC,EAAyBC,GAGlD,GAAc,OAAVD,GAA2B,OAATC,EACrB,MAAM,IAAIC,MAAM,wDAMjB,GAAID,EAAOD,EACV,MAAM,IAAIE,MAAM,yCAGjB,OAAQJ,GAAcE,GAASF,GAAaA,GAAaG,EAGpD,SAAUE,EAAWC,GAC1B,OAAO,WAGQC,IACf,OAAO,EAGQ,SAAAC,EAAMN,EAAkBO,GACvC,OAAQT,GAAcE,EAAMF,IAAcS,EAAKT,GC3BhD,SAASU,EAAYC,EAA4BC,GAChD,OAAQA,EAAKC,MACZ,IAAK,YAGJ,YADAF,EAAUG,KAAKF,EAAKG,OAIrB,IAAK,SAGJ,YADAC,EAAcL,EAAWC,EAAKG,OAAO,IA+CxC,SAASE,EAAcN,EAA4BO,GAElDA,EAAOC,QAASC,KA5CjB,SAAsBT,EAA4BS,GAEjD,MAAOC,GAASC,IAAEA,EAAGC,IAAEA,IAASH,EAChC,GAAY,OAARG,EAAJ,CA0BA,IAAK,IAAIC,EAAI,EAAGA,EAAIF,IAAOE,EAC1Bd,EAAYC,EAAWU,GAExB,IAAK,IAAIG,EAAIF,EAAKE,EAAID,IAAOC,EAAG,CAC/B,MAAMC,EAAOd,EAAUe,KAAK,IAE5BD,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,QACjCpB,EAAYC,EAAWU,GAEvBI,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,cAjCjC,GAAIR,EAAM,EAAG,CACZ,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAM,IAAKE,EAC9Bd,EAAYC,EAAWU,GAGxB,MAAMU,EAAQpB,EAAUkB,QAAQC,OAChCpB,EAAYC,EAAWU,GACVV,EAAUe,KAAK,CAACK,IACxBJ,KAAKC,KAAKjB,EAAUkB,QAAQC,YAC3B,CAEN,MAAMC,EAAQpB,EAAUkB,QAAQC,OAC1BL,EAAOd,EAAUe,KAAK,IAE5BD,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,QACjCpB,EAAYC,EAAWU,GACvBV,EAAUe,KAAK,CAACK,IAEhBN,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,SAsBlCE,CAAarB,EAAWS,cAIVJ,EACfL,EACAsB,EACAC,GAEA,MAAMH,EAAQpB,EAAUkB,QAAQC,OAG1BL,EAAOd,EAAUe,KAAK,IAIxBQ,IACHT,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,QACjCnB,EAAUG,KAAK,KAAM,GACrBH,EAAUe,KAAK,CAACK,KAIjB,MAAMI,EAAuB,GAY7B,GAXAF,EAAOd,QAASD,IACfO,EAAKE,KAAKC,KAAKjB,EAAUkB,QAAQC,QACjCb,EAAcN,EAAWO,GACzBiB,EAAMP,KAAKjB,EAAUe,KAAK,OAE3BS,EAAMhB,QAASiB,IACdA,EAAKT,KAAKC,KAAKjB,EAAUkB,QAAQC,UAK9BI,EAAgB,CACnB,MAAMG,EAAa1B,EAAUkB,QAAQC,OAC/BQ,EAAa3B,EAAUe,KAAK,IAClCY,EAAWX,KAAKC,KAAKjB,EAAUkB,QAAQC,QAEvCnB,EAAUG,KAAK,KAAM,GAErBH,EAAUe,KAAK,CAACW,IAEhBC,EAAWX,KAAKC,KAAKjB,EAAUkB,QAAQC,SCjFzB,SAAAS,EAAeC,EAAgBzB,GAC9C,MAAO,CAAE0B,SAAS,EAAMD,OAAAA,EAAQzB,MAAAA,GAW3B,SAAU2B,EAAGF,GAClB,OAAOD,EAAYC,OAAAA,GAYd,SAAUG,EACfH,EACAzC,EACA6C,GAAiB,GAEjB,MAAO,CAAEH,SAAAA,EAAgBD,OAAAA,EAAQzC,SAAAA,EAAU6C,MAAAA,GAUtC,SAAUC,EAAMA,GACrB,MAAO,CAACC,EAAON,KACd,MAAMO,EAAcP,EAASK,EAAMf,OACnC,OAAIgB,EAAME,MAAMR,EAAQO,KAAiBF,EACjCN,EAAYQ,EAAaF,GAE1BF,EAAMH,EAAQ,CAACK,KA6HR,SAAAI,EAAUC,EAAmBD,GAC5C,MAAO,CAACH,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,QAGFF,EAAYY,EAAIX,OAAQS,EAAIE,EAAIpC,QAF/BoC,GA4BMC,SAAAA,EACfF,EACAE,EACArD,GAEA,MAAO,CAAC+C,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,QAGJW,EAAOD,EAAIpC,OAGToC,EAFCR,EAAMH,EAAQzC,GAHdoD,GAmBM,SAAAE,EAAMC,EAAsBvD,GAC3C,MAAO,CAAC+C,EAAON,KACd,IAAIe,EAAmC,KACvC,IAAK,MAAML,KAAUI,EAAS,CAC7B,MAAMH,EAAMD,EAAOJ,EAAON,GAC1B,GAAIW,EAAIV,QACP,OAAOU,EAQR,GALkB,OAAdI,GAAsBJ,EAAIX,OAASe,EAAUf,OAChDe,EAAYJ,EACFA,EAAIX,SAAWe,EAAUf,aAAuBgB,IAAbzD,IAC7CwD,EAAUxD,SAAWwD,EAAUxD,SAAS0D,OAAON,EAAIpD,WAEhDoD,EAAIP,MACP,OAAOO,EAOT,OAJApD,EAAWA,IAAYwD,MAAAA,OAAAA,EAAAA,EAAWxD,WAAY,GAC1CwD,IACHA,EAAUxD,SAAWA,GAEfwD,GAAaZ,EAAMH,EAAQzC,IAc9B,SAAU2D,EAAYR,GAC3B,MAAO,CAACJ,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,SAAYU,EAAIP,MAIlBO,EAHCZ,EAAYC,EAAQ,OAkBxB,SAAUmB,EAAQT,GACvB,MAAO,CAACJ,EAAON,KACd,IAAIoB,EAAU,GACVC,EAAarB,EACjB,OAAa,CACZ,MAAMW,EAAMD,EAAOJ,EAAOe,GAC1B,IAAKV,EAAIV,QAAS,CACjB,GAAIU,EAAIP,MACP,OAAOO,EAER,MAGD,GADAS,EAAGhC,KAAKuB,EAAIpC,OACRoC,EAAIX,SAAWqB,EAElB,MAEDA,EAAaV,EAAIX,OAGlB,OAAOD,EAAYsB,EAAYD,IAuDYE,SAc7BC,EACfC,EACAC,EACA7B,GAEA,MAAO,CAACU,EAAON,KACd,MAAM0B,EAAKF,EAAQlB,EAAON,GAC1B,IAAK0B,EAAGzB,QACP,OAAOyB,EAER,MAAMC,EAAKF,EAAQnB,EAAOoB,EAAG1B,QAC7B,OAAK2B,EAAG1B,QAGDF,EAAY4B,EAAG3B,OAAQJ,EAAK8B,EAAGnD,MAAOoD,EAAGpD,QAFxCoD,GAkBJ,SAAUC,EAAQlB,GACvB,OAAOa,EAAKb,EAAQS,EAAKT,GAAS,CAACY,EAAGO,IAAO,CAACP,GAAGL,OAAOY,IAYzC,SAAAnE,EAAcoE,EAAOC,GACpC,OAAOD,EAYQ,SAAAE,EAAeF,EAAOC,GACrC,OAAOA,EA8BQ,SAAAE,EAAqBC,EAAyBxB,GAC7D,OAAOa,EAAKW,EAAQxB,EAAQsB,GAeb,SAAAG,EAAoBzB,EAAmB0B,GACtD,OAAOb,EAAKb,EAAQ0B,EAAO1E,GAkBtB,SAAU2E,EACfC,EACAC,EACAC,EACAC,GAAAA,GAGA,OAAOR,EAASK,EADHG,EAAeC,EAAIP,EAASI,EAAOC,IAAUL,EAASI,EAAOC,IAuD3D,SAAAG,EAAOjC,EAAmBnD,GACzC,MAAO,CAAC+C,EAAON,IACFU,EAAOJ,EAAON,GACjBC,QAGFE,EAAMH,EAAQzC,GAFb2C,EAAGF,GA6BP,SAAU0C,EAAOhC,GACtB,MAAO,CAACJ,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,QAGFU,EAFCR,EAAMQ,EAAIX,OAAQW,EAAIpD,UAAU,UAyB7BqF,EAAoB,CAACtC,EAAON,IACxCM,EAAMhB,SAAWU,EAASE,EAAGF,GAAUG,EAAMH,EAAQ,CAAC,iBCxoBhD,MAAM6C,EAAa,CACzB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MAyLKC,EAA4C,GCzM5C,SAAUC,EAAYC,GAC3B,OAAOA,EAAKC,YAAY,GDyMzB,mEAAmEC,MAAM,IAAIvE,QAAQ,CAACwE,EAAGnE,KACxF8D,EAAeK,GAAKnE,ICvMrB,MAAMoE,EAAuB5F,IJeO,IIdnCA,IJeiC,IIfKA,EAEjC,SAAU6F,EAAWC,GAC1B,OAAQ9F,IAAe4F,EAAS5F,KAAe8F,EAAU9F,GAG1C,SAAA+F,EAAWD,EAAsBE,GAChD,OAAe,OAAXA,EACIF,EAEA9F,GAAc8F,EAAU9F,KAAegG,EAAOhG,GAGvD,MAAMiG,ECUU,SACfC,EACAC,GAEA,MAAMF,EAAuD,IAAIG,IACjE,IAAIlG,EAAmB,EAevB,OAdAgG,EAAM/E,QAAQ,CAACkF,EAAqBC,KACnC,MAAMxE,EAASqE,EAAQG,GACV,OAATD,GACHA,EAAKX,MAAM,KAAKvE,QAASkF,IACxB,MAAME,EAAWN,EAA6BO,IAAIH,GAC5CP,EAAY7F,EAAUC,EAAOA,EAAQ4B,EAAS,GACpDmE,EAA6BQ,IAC5BJ,EACAE,EAAW/F,EAAM+F,EAAUT,GAAaA,KAI3C5F,GAAS4B,IAEHmE,ED9BqDS,0rNACvDC,ED2LA,SAA2BC,GAChC,MAAMD,EAA8C,IAAIP,IAClDS,EAAiBD,EAAOlB,MAAM,IAC9BoB,EAAiCzB,EAAWpC,IAAI,IAAM,IAC5D,IAAI/C,EAAQ,EACRsB,EAAI,EACR,KAAOA,EAAIqF,EAAe/E,QAAQ,CACjC,MAAMiF,EAAkBzB,EAAeuB,EAAerF,IAChDwF,GAA8B,GAAlBD,GAA6B,EAC/C,IAAIjF,EAAS,EAAIwD,EAAeuB,EAAerF,EAAI,IASnD,OARsB,GAAlBuF,GACHjF,GAAUwD,EAAeuB,EAAerF,EAAI,KAAO,EACnDM,GAAUwD,EAAeuB,EAAerF,EAAI,KAAO,GACnDM,GAAUwD,EAAeuB,EAAerF,EAAI,KAAO,GACnDA,GAAK,GAELA,GAAK,EAEEwF,GACP,KAAM,EAAG,CACR,IAAIC,EAAiB,EACrB,IAAK,IAAIjH,EAAYE,EAAOF,EAAYE,EAAQ4B,IAAU9B,EAAW,CACtD8G,EAAgBG,GACxBrF,KAAK9B,EAAWE,IACtBiH,GAAkBA,EAAiB,GAAK,EAEzC,MAGD,KAAM,EAEL,MAED,QAAS,CACR,MAAMC,EAAQJ,EAAgBE,GACf,IAAXlF,EACHoF,EAAMtF,KAAK9B,EAAWI,IAEtBgH,EAAMtF,KAAK3B,EAAUC,EAAOA,EAAQ4B,EAAS,IAE9C,OAGF5B,GAAS4B,EAEV,MAAMqF,EAA0C,IAAIf,IAYpD,OAXAf,EAAWlE,QAAQ,CAACiG,EAAU5F,KAC7B,MAAMsE,EAAYgB,EAAgBtF,GAAG6F,OAAO7G,EAAOD,GACnDoG,EAAoBF,IAAIW,EAAUtB,GAClC,MAAMwB,EAASF,EAASG,OAAO,GACzBL,EAAQC,EAAcX,IAAIc,IAAW,GAC3CH,EAAcV,IAAIa,EAAQJ,GAC1BA,EAAMtF,KAAKkE,KAEZqB,EAAchG,QAAQ,CAAC+F,EAAOI,KAC7BX,EAAoBF,IAAIa,EAAQJ,EAAMG,OAAO7G,EAAOD,MAE9CoG,ECpP4Ca,k7LA0BpD,SAASC,EAAWzH,GAEnB,OAAqB,KAAdA,GAAoC,IAAdA,GAAmC,KAAdA,GAAmC,KAAdA,EAIxE,MAAM0H,EAAgB,CACrB5H,EAAWyF,EAAY,MACvBtF,EAAUsF,EAAY,KAAMA,EAAY,MACxCzF,EAAWyF,EAAY,MACvBtF,EAAUsF,EAAY,KAAMA,EAAY,MACxCtF,EAAU,IAAM,KAChBA,EAAU,IAAM,KAChBA,EAAU,IAAM,KAChBA,EAAU,IAAM,KAChBA,EAAU,IAAM,KAChBA,EAAU,IAAO,KACjBA,EAAU,IAAO,MACjBA,EAAU,KAAQ,MAClBA,EAAU,KAAQ,MAClBA,EAAU,MAAQ,OAClBA,EAAU,MAAQ,OAClBA,EAAU,MAAQ,OAClBA,EAAU,MAAQ,OAClBA,EAAU,MAAS,SAClBoH,OAAO7G,GAEHmH,EAAW,CAChBD,EACA5H,EAAWyF,EAAY,MACvBzF,EAAWyF,EAAY,MACvBtF,EAAUsF,EAAY,KAAMA,EAAY,MACxCzF,EAAW,KACXG,EAAU,IAAO,KACjBA,EAAU,KAAQ,OACjBoH,OAAO7G,GAEHoH,EAAQjB,EAAoBH,IAAI,MAChCqB,EAAWhC,EAAW+B,GACtBE,EAAW/B,EAChB9F,EAAU,EAAQ,SAClB,CACC0G,EAAoBH,IAAI,KACxBG,EAAoBH,IAAI,KACxBG,EAAoBH,IAAI,MACvBa,OAAO7G,IAEJuH,EAAclC,EAAWiC,GAEzB,SAAUE,EAAShI,GAExB,OAAqB,KAAdA,GAAmC,KAAdA,IAAsB4F,EAAS5F,GAGrD,MAAMiI,EAAY,CACxBC,EAAGT,EACHU,EAAGtC,EAAW4B,GACdjG,EAAGkG,EACHU,EAAGvC,EAAW6B,GACd/B,EAAGgC,EACHU,EAAGxC,EAAW8B,GACdW,EAAGV,EACHW,EAAGV,EACHW,EAAGV,EACHW,EAAGV,GErFEW,EAAW7F,EAAM,KACjB8F,EAAY9F,EAAM,MAClB+F,EAAa/F,EAAM,KACnBgG,EAAchG,EAAM,KACpBiG,EAAejG,EAAM,KACrBkG,EAAgBlG,EAAM,KACtBmG,EAAQnG,EAAM,KACdoG,EAASpG,EAAM,KACfqG,GAAQrG,EAAM,KACdsG,GAAStG,EAAM,KACfuG,GAAmBvG,EAAM,KACzBwG,GAAoBxG,EAAM,KAC1ByG,GAASzG,EAAM,KACf0G,GAAO1G,EAAM,KACb2G,GAAO3G,EAAM,KACb4G,GAAgB5G,EAAM,KACtB6G,GAAkB7G,EAAM,MAExB8G,GAAkBpE,EAAY,KAE9B,SAAUqE,GAAeC,GAC9B,SAASC,EAAkBC,GAC1B,OAAO,IAAIC,IAAID,EAAMrE,MAAM,IAAIzC,IAAK0C,GAAMJ,EAAYI,KAGvD,SAAS3F,EAAU8C,EAAeN,GACjC,MAAMxC,EAAY8C,EAAM2C,YAAYjD,GACpC,YAAkBgB,IAAdxD,EACI2C,EAAMH,EAAQ,CAAC,kBAEhBD,EAAYC,EAASyH,OAAOC,cAAclK,GAAW8B,OAAQ9B,GAKrE,MAAMmK,EACgB,UAArBN,EAAQO,SACL3F,EACAkE,EACAtF,EAAG,CACFJ,EAAIJ,EAAM,KAAM,IAAM,IACtBI,EAAIJ,EAAM,KAAM,IAAM,IACtBI,EAAIJ,EAAM,KAAM,IAAM,GACtBI,EACCI,EAAG,CACFsF,EACAY,GACAD,GACAH,GACAH,EACAS,GACAf,EACAc,GACAZ,EACAC,EACAI,EACAG,GACAC,GACAP,EACAC,IAEApD,GAAMJ,EAAYI,OAIrBlB,EACAkE,EACAtF,EAAG,CACFJ,EAAIJ,EAAM,KAAM,IAAM,IACtBI,EAAIJ,EAAM,KAAM,IAAM,IACtBI,EAAIJ,EAAM,KAAM,IAAM,GACtBI,EACCI,EAAG,CACFsF,EACAY,GACAD,GACAH,GACAH,EACAS,GACAf,EACAc,GACAZ,EACAC,EACAO,GACAC,GACAP,EACAC,IAEApD,GAAMJ,EAAYI,OAOzB,SAAS0E,EAAmBC,EAAiBC,GAC5C,MAAMC,EAAiBV,EAAkBS,GACzC,OAAOxG,EACNlB,EAAMyH,GACN5G,EACCN,EACCpD,EACCA,GAAcwK,EAAeC,IAAIzK,GAClCuK,EAAY7E,MAAM,MAGpB,CAACgF,EAAGxC,IF/FD,SAA0ByC,GAC/B,MAAM7E,EAAYa,EAAoBH,IAAImE,GAG1C,GAAiBnH,MAAbsC,EACH,MAAM,IAAI1F,MAASuK,EAAH,oCAEjB,OAAO7E,EEwFK8E,CAAsB,OAAN1C,EAAawC,EAAIA,EAAIT,OAAOC,cAAchC,KAItE,MAQM2C,EAAgCxH,EAAG,CARzBgH,EAAmB,IAAK,SAC1BA,EAAmB,IAAK,OACtBA,EAAmB,IAAK,OACpBA,EAAmB,IAAK,WACzBA,EAAmB,IAAK,OAC3BA,EAAmB,IAAK,QACzBA,EAAmB,IAAK,UAcjCS,EAAmC,CACxCC,EAAmBxF,EAAY,KAAMA,EAAY,MACjDwF,EAAmBxF,EAAY,KAAMA,EAAY,MACjDwF,EAAmBxF,EAAY,KAAMA,EAAY,MACjDyF,EAAoB,KACnB3D,OAAO7G,GAYHyK,EAA8B5H,EAAG,CAACwH,EAVL5H,EAClCwB,EACC5B,EAAM,MJkXH,SAAuBK,GAC5B,MAAO,CAACJ,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,QAGFF,EAAYY,EAAIX,OAAQM,EAAME,MAAMR,EAAQW,EAAIX,SAF/CW,GIrXP+H,CAAU9G,EAAKhB,EAAOpD,EAAW8K,EAAuB,CAAC,wBAEzDH,GFjJa,SAAaA,EAAoBQ,GAEhD,MAAMrF,EAAYG,EAA6BO,IAAImE,GACnD,QAAkBnH,IAAdsC,EAAyB,CAC5B,GAAIqF,EAEH,OAAO9K,EAGR,MAAM,IAAID,MAAM,iCAAiCuK,oBAElD,OAAO7E,EEsIUsF,CAAaT,EAAiC,UAArBd,EAAQO,aAO5CiB,EAA4BxG,EAAUhC,EAAM,QAASoI,EAAUpC,GAAa,GAE5EyC,EAA8BrI,EACnC4B,EAAUhC,EAAM,QAASoI,EAAUpC,GAAa,GAChDhD,GAKK0F,EAAkC9G,EACvCkE,EACA1F,EACCI,EAAG,aAAaqC,MAAM,IAAIzC,IAAK0C,GAAM9C,EAAM8C,KAC1CA,GAAMsC,EAAUtC,KAIb6F,EAAiCvI,EAAIqG,GAAQ,IAAMtB,GAInDyD,EAAkCpI,EAAG,CAACkI,EAAcF,EAAQC,IAI5DI,EAAqB5B,EAAkB,QAQvChK,EAAgCuD,EAAG,CAAC8G,EANC/G,EAC1CpD,EACCA,IAAe0L,EAAmBjB,IAAIzK,GACvC,CAAC,0BAOI2L,EAAmDtI,EAAG,CAC3DJ,EAAIkG,GAAQ,IAAM,MAClBrJ,IAGKG,EAA+B8D,EACpC4H,EACAlH,EAAS0E,GAAQwC,GACjBZ,GAKD,SAASa,EAAQ1L,EAAU2L,GAC1B,MAAO,CAAC3L,GAAOuD,OAAOoI,GAAQ,IAG/B,MAAMC,GAAqC7I,EJuUtC,SAAkBC,GACvB,MAAO,CAACJ,EAAON,KACd,MAAMW,EAAMD,EAAOJ,EAAON,GAC1B,OAAKW,EAAIV,QAGFF,EAAYC,EAAQW,EAAIpC,OAFvBoC,GI1UR4I,CAAK1I,EAAG,CAAC0F,EAAeW,MACxB,IAAM,MAGDsC,GAAkBzG,EAAY,KAM9B0G,GAA+C5I,EAAG,CALGJ,EAC1D0B,EAASA,EAASwE,GAAQhE,EAAI2D,EAAc,CAAC,WAAYgD,IACzD,IAAME,IAKNvH,EAASU,EAAIgE,GAAQ,CAAC,UAAWrJ,KAG5BoM,GAAqD7I,EAAG,CAC7DU,EACCd,EAAIgJ,GAA2BjB,GAC/B3H,EAAG,CAUL,SACCP,EACAN,GAEA,OAAO0J,GAA8BpJ,EAAON,IAdAsJ,KAC3CF,GAED7H,EACCV,EAAG,CAACpD,EAAWwL,IACfpI,EAAG,CAAC8I,GAAwBL,KAC5BF,KAWF,MAAMQ,GAAsC/I,EAAG,CAC9CU,EACCd,EAAInD,EAAYkL,GAChB3H,EAAG,CAAC6I,GAA+BJ,KACnCF,GAED7H,EACCV,EAAG,CAACpD,EAAWwL,IACfpI,EAAG,CAAC8I,GAAwBL,KAC5BF,KAIF,SAASO,GAAuBrJ,EAAeN,GAC9C,OAAO4J,GAAetJ,EAAON,GAK9B,MAAM6J,GAAkCpJ,EAAImJ,GAAiBlF,GAAUA,EAAMG,OAAO7G,IAI9E8L,GAAkCrJ,EAAIwB,EAASuE,EAAOqD,IAAexG,GAIrE0G,GAA+BxI,EACpCV,EAAG,CAACoB,EAASU,EAAI6D,EAAO,CAAC,UAAWqD,IAAeC,KACnD5I,EAASe,EAAS0E,IAanB,SAA+BrG,EAAeN,GAC7C,OAAOgK,GAAc1J,EAAON,OAb5BuD,GAKKyG,GAAmC3H,EACxCiE,EACAyD,GACAxD,GACA,GASD,MAAM0D,GACgB,UAArB5C,EAAQO,SACL/G,EAAG,CACHJ,EAAIkH,EAAea,GACnBS,EACAe,GACAhB,EACAvI,EAAI+F,EAAO,IAAOrD,IN3Sa,IM2SIA,GACnC1C,EAAIgG,EAAQ,IAAOtD,IN3SU,IM2SOA,KAEpCtC,EAAG,CACHJ,EAAIkH,EAAea,GACnBS,EACAe,GACAhB,IAKEkB,GACgB,UAArB7C,EAAQO,SACLN,EAAkB,mBAClBA,EAAkB,iBAChB6C,GAAgCvJ,EACrCpD,EACCA,IAAe0M,GAAUjC,IAAIzK,GAC9B,CAAC,eAII4M,GAA+B3J,EACpCwB,EACCkE,EACA5E,EACCd,EACCG,EAAOpD,EAAW+K,EAAmBxF,EAAY,KAAMA,EAAY,MAAO,CACzE,UAEAvF,GAAcA,EAAY2J,IAE5BhG,EACCV,EACCG,EAAOpD,EAAW+K,EAAmBpB,GAAiBpE,EAAY,MAAO,CACxE,UAEAvF,GAAcA,EAAY2J,KAG7B,CAACkD,EAAYC,KACZA,EAAWzF,OAAO,CAAC0F,EAAKnF,IAAgB,GAANmF,EAAWnF,EAAOiF,MAItDG,IACA,MAAM,IAAI5M,MAAM,+DAMZQ,GACgB,UAArBiJ,EAAQO,SACL/G,EAAS,CACTJ,EAAI0J,GAAa3M,IAAe,CAC/Ba,KAAM,YACNE,MAAOiK,EAAoBhL,MAE5BiD,EAAIwJ,GAAY3G,IAAe,CAAEjF,KAAM,YAAaE,MAAO+E,KAC3D7C,EACC4B,EACCuE,GACA3E,EAASf,EAASb,EAAM,OAAQoK,IAChC5D,IACA,GAEA6D,IAAY,CACZrM,KAAM,SACNE,MAAOmM,KAGTN,KAEAvJ,EAAS,CACTJ,EAAI0J,GAAa3M,IAAe,CAC/Ba,KAAM,YACNE,MAAOiK,EAAoBhL,MAE5BiD,EAAIwJ,GAAY3G,IAAe,CAAEjF,KAAM,YAAaE,MAAO+E,KAC3D7C,EACC4B,EAAUuE,GAAkB6D,GAAgB5D,IAAmB,GAC9D6D,IAAY,CACZrM,KAAM,SACNE,MAAOmM,OAQPC,GAA6BlK,EAClCmB,EACCnB,EAAIG,EAAOpD,EAHG+K,EAAmBpB,GAAiBpE,EAAY,MAG/B,CAAC,UAAYvF,GAAcA,EAAY2J,KAEtEyD,GAAWA,EAAO/F,OAAO,CAACgG,EAAKzF,IAAgB,GAANyF,EAAWzF,IAgBhD0F,GAA+BjK,EAAG,CAbDU,EACtCoJ,GACA1I,EAASyE,GAAOiE,IAChB,CAAC7L,EAAKC,KACL,GAAIA,EAAMD,EACT,MAAM,IAAIlB,MAAM,0CAEjB,MAAO,CAAEkB,IAAAA,EAAKC,IAAAA,KAIqBwC,EAAKoJ,GAAYjE,GAAQ5H,IAAS,CAAEA,IAAAA,EAAKC,IAAK,QAKlF0B,EAAIkK,GAAaI,IAAO,CAAEjM,IAAKiM,EAAGhM,IAAKgM,OAGlCC,GACgB,UAArB3D,EAAQO,SACLrG,EACAV,EAAe,CACdJ,EAAIwG,GAAe,MAASnI,IAAK,EAAGC,IAAK,KACzC0B,EAAIyF,EAAU,MAASpH,IAAK,EAAGC,IAAK,QACpC0B,EAAIuG,GAAM,MAASlI,IAAK,EAAGC,IAAK,QAChCsD,EAAU+D,EAAY0E,GAAUzE,GAAa,KAE9CnF,EAAS+F,IACT,CAAC+D,EAAYC,IAAiBD,GAE9BnK,EAAe,CACfJ,EAAIwG,GAAe,MAASnI,IAAK,EAAGC,IAAK,KACzC0B,EAAIyF,EAAU,MAASpH,IAAK,EAAGC,IAAK,QACpC0B,EAAIuG,GAAM,MAASlI,IAAK,EAAGC,IAAK,QAChCsD,EAAU+D,EAAY0E,GAAUzE,GAAa,KAa3C3H,GAAyByC,EARFI,EAC5BnD,GACAqC,EAAIS,EAAS8J,IAAcD,GAAa,OAANA,EAAa,CAAEjM,IAAK,EAAGC,IAAK,GAAMgM,GACpE,CAACG,EAAGH,IAAM,CAACG,EAAGH,KASTL,GAAyBnJ,EAAK7C,GAAQyC,EAAKc,EAAS8E,GAAMrE,EAAIhE,MAAW,CAACyM,EAAGC,IAClF,CAACD,GAAGlK,OAAOmK,IAGZ,SAASX,GAAenK,EAAeN,GACtC,OAAO0K,GAAOpK,EAAON,GAYtB,MAAMqL,GJ8JD,SAAsB3K,GAC3B,OAAOa,EAAKb,EAAQkC,EAAKlF,GI/Jc4N,CAASZ,IAEhD,OAAO,SAAepK,GACrB,IAAIK,EACJ,IACCA,EAAM0K,GAAe/K,EAAO,GAC3B,MAAOH,GAER,MAAM,IAAIvC,MACT,0BAA0B0C,OACzBH,aAAiBvC,MAAQuC,EAAMoL,QAAUpL,KAI5C,OAAKQ,EAAIV,QAIFU,EAAIpC,MA3BZ,SAAyB+B,EAAeN,EAAgBzC,GACvD,MAAMiO,EAASjO,EAASkD,IAAKgL,GAAQ,IAAIA,MACzC,MAAM,IAAI7N,MACT,0BAA0B0C,gBAAoBN,eAC7CwL,EAAOlM,OAAS,EAAI,UAAYkM,EAAO5L,KAAK,MAAQ4L,EAAO,iBAC7ClL,EAAME,MAAMR,EAAQA,EAAS,OAmBrC0L,CAAgBpL,EAAOK,EAAIX,OAAQW,EAAIpD,WCjgBjD,SAASoO,GAAaF,GACrB,MAAO,IAAIA,GAAKhL,IAAK0C,GAAMA,EAAEF,YAAY,cAmCpC,SAAkB2I,EAAiBvE,EAAmB,CAAEO,SAAU,QACvE,MAAMiE,EAAMzE,GAAeC,EAAfD,CAAwBwE,GAE9BE,EAAKC,YAAmB5N,IAC7BK,EAAcL,EAAW0N,EAA0B,UAArBxE,EAAQO,UACtCzJ,EAAU6N,WAGX,OAAO,SAAeP,GACrB,MAAMQ,EACgB,UAArB5E,EAAQO,SACL,EPjB8B,KOiBJ+D,GAAaF,IPhBX,GOiB5BE,GAAaF,GACjB,OAAOK,EAAGI,QAAQD,GAAYhM"}