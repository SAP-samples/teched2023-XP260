/**
 * The Assembler is used to generate a whynot program by appending instructions.
 *
 * @public
 */
export declare class Assembler<TInput, TRecord, TOptions = void> {
    readonly program: Instruction<TInput, TRecord, TOptions>[];
    /**
     * The 'test' instruction validates and consumes an input item.
     *
     * If the matcher returns true, execution continues in the next Generation, otherwise execution
     * of the current Thread ends.
     *
     * @param matcher - Callback to invoke for the input, should return true to accept, false to
     *                  reject.
     * @param data    - Data to be passed to the matcher callback. Defaults to null.
     *
     * @returns The new instruction
     */
    test(matcher: TestFunc<TInput, TOptions>, data?: any): Instruction<TInput, TRecord, TOptions>;
    /**
     * The 'jump' instruction continues execution in the current Generation at any number of other
     * locations. A new Thread will be spawned for each target.
     *
     * @param targets - Program counters at which to continue execution
     *
     * @returns The new instruction
     */
    jump(targets: number[]): Instruction<TInput, TRecord, TOptions>;
    /**
     * The 'record' instruction adds a custom record to the current Thread's trace and resumes
     * execution at the next instruction in the same Generation.
     *
     * @param data     - Data to record
     * @param recorder - Callback to generate the record based on data and the current input
     *                   position. Defaults to recording data.
     *
     * @returns The new instruction
     */
    record<TRecorder>(data: TRecorder extends undefined ? TRecord : any, recorder?: RecordFunc<TRecord, TOptions>): Instruction<TInput, TRecord, TOptions>;
    /**
     * The 'bad' instruction permanently lowers the priority of all threads originating in the
     * current one.
     *
     * @param cost - Amount to increase badness with. Defaults to 1.
     *
     * @returns The new instruction
     */
    bad(cost?: number): Instruction<TInput, TRecord, TOptions>;
    /**
     * The 'accept' instruction causes the VM to yield the current Thread's Trace upon completion,
     * provided all input has been consumed. Otherwise, the Thread ends.
     *
     * @returns The new instruction
     */
    accept(): Instruction<TInput, TRecord, TOptions>;
    /**
     * The 'fail' instruction ends the current Thread.
     *
     * @param predicate - Optional callback to make the fail conditional, if this returns true the
     *                    thread will end, otherwise it will continue.
     *
     * @returns The new instruction
     */
    fail(predicate?: FailFunc<TOptions>): Instruction<TInput, TRecord, TOptions>;
}

/**
 * Convenience helper function that creates a new VM using the specified callback for compilation.
 *
 * @public
 *
 * @param compile - Function used to compile the program, invoked with an Assembler as the only
 *                  parameter.
 *
 * @returns VM running the compiled program
 */
export declare function compileVM<TInput, TRecord = void, TOptions = void>(compile: (assembler: Assembler<TInput, TRecord, TOptions>) => void): VM<TInput, TRecord, TOptions>;

declare const _default: {
    Assembler: typeof Assembler;
    VM: typeof VM;
    compileVM: typeof compileVM;
};
export default _default;

declare type FailFunc<TOptions = void> = (options?: TOptions) => boolean;

/**
 * Represents a single instruction in a whynot program.
 */
declare interface Instruction<TInput, TRecord, TOptions = void> {
    op: Operation;
    func?: FailFunc<TOptions> | TestFunc<TInput, TOptions> | RecordFunc<TRecord, TOptions> | null;
    data?: any;
}

/**
 * Represents the type of operation to perform.
 */
declare const enum Operation {
    /**
     * Accept the current trace if all of the input has been processed.
     */
    ACCEPT = 0,
    /**
     * Increase the badness value of the current thread.
     */
    BAD = 1,
    /**
     * Stop executing the current thread (possibly conditional).
     */
    FAIL = 2,
    /**
     * Continue the thread at (or fork it to) one or more other places.
     */
    JUMP = 3,
    /**
     * Add a record to all traces that pass this instruction.
     */
    RECORD = 4,
    /**
     * Check the input item using a callback, and only continue the thread for the next input item
     * if it returns true.
     */
    TEST = 5
}

declare type RecordFunc<TRecord, TOptions = void> = (data: any, inputIndex: number, options?: TOptions) => TRecord | null | undefined;

/**
 * The result of running a VM on an input sequence.
 *
 * @public
 */
declare class Result<TRecord> {
    /**
     * The traces that lead to input being accepted, or an empty array if the input was not
     * accepted by the program.
     */
    readonly acceptingTraces: Trace<TRecord>[];
    /**
     * Whether the input was accepted by the program.
     */
    readonly success: boolean;
    constructor(
    /**
     * The traces that lead to input being accepted, or an empty array if the input was not
     * accepted by the program.
     */
    acceptingTraces: Trace<TRecord>[]);
}

declare type TestFunc<TInput, TOptions = void> = (inputItem: TInput, data: any, options?: TOptions) => boolean;

/**
 * A Trace represents the execution history of a Thread in terms of the records gathered. Only paths
 * that differ in terms of these records are preserved.
 *
 * Trace is never cyclic (i.e., a given Trace is never included in its prefixes, including,
 * recursively, the prefixes thereof).
 *
 * Trace instances are often reused and should therefore never be mutated after creation.
 */
declare class Trace<TRecord> {
    readonly prefixes: Trace<TRecord>[];
    readonly record: TRecord | null;
    constructor(prefixes: Trace<TRecord>[], record: TRecord | null);
    /**
     * Single instance used to represent the empty trace from which all programs start.
     */
    static EMPTY: Trace<any>;
}

/**
 * A virtual machine to execute whynot programs.
 *
 * @public
 */
export declare class VM<TInput, TRecord, TOptions = void> {
    private readonly _program;
    private readonly _programInfo;
    private readonly _schedulers;
    /**
     * @param program - The program to run, as created by the Assembler
     */
    constructor(program: Instruction<TInput, TRecord, TOptions>[]);
    /**
     * Executes the program in the VM with the given input stream.
     *
     * @param input   - An array of input items.
     * @param options - Optional object passed to all instruction callbacks.
     *
     * @returns Result of the execution, containing all Traces that lead to acceptance of the input
     *          (if any)
     */
    execute(input: TInput[], options?: TOptions): Result<TRecord>;
}

export { }
