{"version":3,"file":"whynot.umd.js","sources":["../src/Assembler.ts","../src/ProgramInfo.ts","../src/Result.ts","../src/Generation.ts","../src/FromBuffer.ts","../src/LazySet.ts","../src/Trace.ts","../src/Tracer.ts","../src/Traces.ts","../src/Scheduler.ts","../src/VM.ts","../src/index.ts"],"sourcesContent":["import { Instruction, FailFunc, TestFunc, RecordFunc, Operation } from './Instruction';\n\nfunction addInstruction<TInput, TRecord, TOptions>(\n\tprogram: Instruction<TInput, TRecord, TOptions>[],\n\top: Operation,\n\tfunc: FailFunc<TOptions> | TestFunc<TInput, TOptions> | RecordFunc<TRecord, TOptions> | null,\n\tdata: any\n): Instruction<TInput, TRecord, TOptions> {\n\tconst instruction = { op, func, data };\n\tprogram.push(instruction);\n\treturn instruction;\n}\n\nfunction defaultRecorder<TRecord>(data: TRecord, _inputIndex: number): TRecord {\n\treturn data;\n}\n\n/**\n * The Assembler is used to generate a whynot program by appending instructions.\n *\n * @public\n */\nexport default class Assembler<TInput, TRecord, TOptions = void> {\n\treadonly program: Instruction<TInput, TRecord, TOptions>[] = [];\n\n\t/**\n\t * The 'test' instruction validates and consumes an input item.\n\t *\n\t * If the matcher returns true, execution continues in the next Generation, otherwise execution\n\t * of the current Thread ends.\n\t *\n\t * @param matcher - Callback to invoke for the input, should return true to accept, false to\n\t *                  reject.\n\t * @param data    - Data to be passed to the matcher callback. Defaults to null.\n\t *\n\t * @returns The new instruction\n\t */\n\ttest(matcher: TestFunc<TInput, TOptions>, data?: any): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(\n\t\t\tthis.program,\n\t\t\tOperation.TEST,\n\t\t\tmatcher,\n\t\t\tdata === undefined ? null : data\n\t\t);\n\t}\n\n\t/**\n\t * The 'jump' instruction continues execution in the current Generation at any number of other\n\t * locations. A new Thread will be spawned for each target.\n\t *\n\t * @param targets - Program counters at which to continue execution\n\t *\n\t * @returns The new instruction\n\t */\n\tjump(targets: number[]): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(this.program, Operation.JUMP, null, targets);\n\t}\n\n\t/**\n\t * The 'record' instruction adds a custom record to the current Thread's trace and resumes\n\t * execution at the next instruction in the same Generation.\n\t *\n\t * @param data     - Data to record\n\t * @param recorder - Callback to generate the record based on data and the current input\n\t *                   position. Defaults to recording data.\n\t *\n\t * @returns The new instruction\n\t */\n\trecord<TRecorder>(\n\t\tdata: TRecorder extends undefined ? TRecord : any,\n\t\trecorder?: RecordFunc<TRecord, TOptions>\n\t): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(\n\t\t\tthis.program,\n\t\t\tOperation.RECORD,\n\t\t\trecorder === undefined ? defaultRecorder : recorder,\n\t\t\tdata\n\t\t);\n\t}\n\n\t/**\n\t * The 'bad' instruction permanently lowers the priority of all threads originating in the\n\t * current one.\n\t *\n\t * @param cost - Amount to increase badness with. Defaults to 1.\n\t *\n\t * @returns The new instruction\n\t */\n\tbad(cost: number = 1): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(this.program, Operation.BAD, null, cost);\n\t}\n\n\t/**\n\t * The 'accept' instruction causes the VM to yield the current Thread's Trace upon completion,\n\t * provided all input has been consumed. Otherwise, the Thread ends.\n\t *\n\t * @returns The new instruction\n\t */\n\taccept(): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(this.program, Operation.ACCEPT, null, null);\n\t}\n\n\t/**\n\t * The 'fail' instruction ends the current Thread.\n\t *\n\t * @param predicate - Optional callback to make the fail conditional, if this returns true the\n\t *                    thread will end, otherwise it will continue.\n\t *\n\t * @returns The new instruction\n\t */\n\tfail(predicate?: FailFunc<TOptions>): Instruction<TInput, TRecord, TOptions> {\n\t\treturn addInstruction(this.program, Operation.FAIL, predicate || null, null);\n\t}\n}\n","import { Instruction, Operation } from './Instruction';\n\n/**\n * Computes information about a given program, used to allocate enough space in the data structures\n * required to run that program.\n */\nexport default class ProgramInfo {\n\tprivate constructor(\n\t\tpublic readonly programLength: number,\n\t\tpublic readonly maxFromByPc: number[],\n\t\tpublic readonly maxSurvivorFromByPc: number[]\n\t) {}\n\n\t/**\n\t * Creates an instance with information for the given program.\n\t *\n\t * @param program - The program for which to construct the instance.\n\t */\n\tpublic static fromProgram<TInput, TRecord, TOptions>(\n\t\tprogram: Instruction<TInput, TRecord, TOptions>[]\n\t): ProgramInfo {\n\t\tconst programLength = program.length;\n\n\t\t// Determine maximum number of incoming paths per instructon\n\t\tconst maxFromByPc: number[] = [];\n\t\tconst maxSurvivorFromByPc: number[] = [];\n\t\tprogram.forEach(_ => {\n\t\t\tmaxFromByPc.push(0);\n\t\t\tmaxSurvivorFromByPc.push(0);\n\t\t});\n\t\tprogram.forEach((instruction, pc) => {\n\t\t\tswitch (instruction.op) {\n\t\t\t\tcase Operation.FAIL:\n\t\t\t\t\tif (instruction.func === null) {\n\t\t\t\t\t\t// Unconditional fail, threads will never continue past this instruction\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (pc + 1 >= programLength) {\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\n\t\t\t\t\t}\n\t\t\t\t\tmaxFromByPc[pc + 1] += 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Operation.BAD:\n\t\t\t\tcase Operation.RECORD:\n\t\t\t\t\tif (pc + 1 >= programLength) {\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\n\t\t\t\t\t}\n\t\t\t\t\tmaxFromByPc[pc + 1] += 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Operation.JUMP:\n\t\t\t\t\tconst targets = instruction.data as number[];\n\t\t\t\t\ttargets.forEach(targetPc => {\n\t\t\t\t\t\tif (targetPc < 0 || targetPc >= programLength) {\n\t\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxFromByPc[targetPc] += 1;\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Operation.TEST:\n\t\t\t\t\tif (pc + 1 >= programLength) {\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\n\t\t\t\t\t}\n\t\t\t\t\tmaxSurvivorFromByPc[pc + 1] += 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Operation.ACCEPT:\n\t\t\t\t\tmaxSurvivorFromByPc[pc] += 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\treturn new ProgramInfo(programLength, maxFromByPc, maxSurvivorFromByPc);\n\t}\n\n\t/**\n\t * Creates a stub ProgramInfo with incoming info maxed out to ensure enough space is allocated\n\t * in FromBuffers for simulating any program of the given length.\n\t *\n\t * For testing only.\n\t *\n\t * @param programLength The length of the supposed program\n\t */\n\tpublic static createStub(programLength: number): ProgramInfo {\n\t\tconst maxFromByPc: number[] = [];\n\t\tconst maxSurvivorFromByPc: number[] = [];\n\t\tfor (let i = 0; i < programLength; ++i) {\n\t\t\tmaxFromByPc.push(programLength);\n\t\t\tmaxSurvivorFromByPc.push(programLength);\n\t\t}\n\n\t\treturn new ProgramInfo(programLength, maxFromByPc, maxSurvivorFromByPc);\n\t}\n}\n","import Trace from './Trace';\n\n/**\n * The result of running a VM on an input sequence.\n *\n * @public\n */\nexport default class Result<TRecord> {\n\t/**\n\t * Whether the input was accepted by the program.\n\t */\n\tpublic readonly success: boolean;\n\n\tconstructor(\n\t\t/**\n\t\t * The traces that lead to input being accepted, or an empty array if the input was not\n\t\t * accepted by the program.\n\t\t */\n\t\tpublic readonly acceptingTraces: Trace<TRecord>[]\n\t) {\n\t\tthis.success = acceptingTraces.length > 0;\n\t}\n}\n","/**\n * Perform a binary search to find the index of the first thread with lower badness, within the\n * given bounds.\n *\n * This can then be the index at which to insert a new pc while preserving ordering according to\n * badness.\n *\n * @param pcs         - The array of scheduled pcs to search.\n * @param badnessByPc - Provides the current badness value for each pc in the array.\n * @param badness     - The badness to compare to (i.e., the value for the pc to be inserted).\n * @param first       - First index in pcs to consider.\n * @param length      - The length of the sub-array of pcs to consider. Also the highest index that\n *                      can be returned by this function.\n */\nfunction findInsertionIndex(\n\tpcs: Uint16Array,\n\tbadnessByPc: Uint8Array,\n\tbadness: number,\n\tfirst: number,\n\tlength: number\n): number {\n\tlet low = first;\n\tlet high = length;\n\twhile (low < high) {\n\t\t// Use zero-filling shift as integer division\n\t\tconst mid = (low + high) >>> 1;\n\t\t// Compare to mid point, preferring right in case of equality\n\t\tif (badness < badnessByPc[pcs[mid]]) {\n\t\t\t// Thread goes in lower half\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\t// Thread goes in upper half\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\n\treturn low;\n}\n\n/**\n * The highest supported badness value. Attempts to set badness higher than this are clamped to this\n * value.\n */\nconst MAX_BADNESS = 255;\n\n/**\n * Schedules threads within a Generation according to their associated badness.\n */\nexport default class Generation {\n\t// Program counters of scheduled threads in order of execution\n\tprivate readonly _scheduledPcs: Uint16Array;\n\tprivate _numScheduledPcs: number = 0;\n\n\t// Index of the next thread to execute in the array above\n\tprivate _nextThread: number = 0;\n\n\t// Badness values for scheduled threads by program counter\n\tprivate readonly _badnessByPc: Uint8Array;\n\n\tconstructor(programLength: number) {\n\t\tthis._scheduledPcs = new Uint16Array(programLength);\n\t\tthis._badnessByPc = new Uint8Array(programLength);\n\t}\n\n\tpublic getBadness(pc: number): number {\n\t\treturn this._badnessByPc[pc];\n\t}\n\n\t/**\n\t * Adds a new entry for pc to the scheduled pcs.\n\t *\n\t * The caller should ensure that pc is not already scheduled.\n\t *\n\t * @param pc      The pc to add\n\t * @param badness The badness to associate with pc\n\t */\n\tpublic add(pc: number, badness: number): void {\n\t\tthis._badnessByPc[pc] = badness > MAX_BADNESS ? MAX_BADNESS : badness;\n\t\tconst insertionIndex = findInsertionIndex(\n\t\t\tthis._scheduledPcs,\n\t\t\tthis._badnessByPc,\n\t\t\tbadness,\n\t\t\tthis._nextThread,\n\t\t\tthis._numScheduledPcs\n\t\t);\n\t\tthis._scheduledPcs.copyWithin(insertionIndex + 1, insertionIndex, this._numScheduledPcs);\n\t\tthis._scheduledPcs[insertionIndex] = pc;\n\t\tthis._numScheduledPcs += 1;\n\t}\n\n\t/**\n\t * Reschedule an already scheduled pc according to a new badness value.\n\t *\n\t * The caller should ensure this is only called for pcs that have already been scheduled.\n\t *\n\t * @param pc      The pc to reschedule\n\t * @param badness The new badness to associate with pc\n\t */\n\tpublic reschedule(pc: number, badness: number): void {\n\t\tconst maxBadness = Math.max(\n\t\t\tthis._badnessByPc[pc],\n\t\t\tbadness > MAX_BADNESS ? MAX_BADNESS : badness\n\t\t);\n\t\tif (this._badnessByPc[pc] !== maxBadness) {\n\t\t\t// Remove any existing unexecuted thread in order to reschedule it\n\t\t\tconst existingThreadIndex = this._scheduledPcs.indexOf(pc, this._nextThread);\n\t\t\tif (existingThreadIndex < 0 || existingThreadIndex >= this._numScheduledPcs) {\n\t\t\t\tthis._badnessByPc[pc] = maxBadness;\n\t\t\t\t// Thread has already been executed, do not reschedule\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remove and re-schedule the thread\n\t\t\t// TODO: use a single copyWithin call instead of two\n\t\t\tthis._scheduledPcs.copyWithin(\n\t\t\t\texistingThreadIndex,\n\t\t\t\texistingThreadIndex + 1,\n\t\t\t\tthis._numScheduledPcs\n\t\t\t);\n\t\t\tthis._numScheduledPcs -= 1;\n\t\t\tthis.add(pc, maxBadness);\n\t\t}\n\t}\n\n\t/**\n\t * Get the next scheduled pc.\n\t *\n\t * This pc will have the lowest badness among all currently scheduled pcs.\n\t *\n\t * Returns null if there are no more scheduled pcs in this Generation.\n\t */\n\tpublic getNextPc(): number | null {\n\t\tif (this._nextThread >= this._numScheduledPcs) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._scheduledPcs[this._nextThread++];\n\t}\n\n\t/**\n\t * Clear all scheduled pcs and badness values so the Generation can be reused.\n\t */\n\tpublic reset(): void {\n\t\tthis._numScheduledPcs = 0;\n\t\tthis._nextThread = 0;\n\t\tthis._badnessByPc.fill(0);\n\t}\n}\n","/**\n * The FromBuffer efficiently stores an \"array of arrays\", which for each instruction index (pc or\n * \"program counter\") tracks the pcs from which steps arrived at that instruction.\n *\n * To prevent allocation during the runtime of the whynot program, this data is stored in a single\n * Uint16Array. This buffer is sized to be able to hold for each pc the maximum number of incoming\n * steps, as derived from the program by ProgramInfo, as well as the current lengths of the\n * sub-array for each pc. The lower programLength entries contain these lengts, while the _mapping\n * array provides the offset at which each pcs data starts.\n */\nexport default class FromBuffer {\n\tprivate readonly _buffer: Uint16Array;\n\tprivate readonly _mapping: number[] = [];\n\n\t/**\n\t * @param maxFromByPc - The maximum number of entries to reserve for each pc.\n\t */\n\tconstructor(maxFromByPc: number[]) {\n\t\tlet offset = maxFromByPc.length;\n\t\tmaxFromByPc.forEach(max => {\n\t\t\tthis._mapping.push(max > 0 ? offset : -1);\n\t\t\toffset += max;\n\t\t});\n\n\t\t// Allocate enough room for lengths and elements\n\t\tthis._buffer = new Uint16Array(offset);\n\t}\n\n\t/**\n\t * Clear the buffer.\n\t *\n\t * This only resets the lengths, as that will make the data for each pc inaccessible.\n\t */\n\tpublic clear(): void {\n\t\tthis._buffer.fill(0, 0, this._mapping.length);\n\t}\n\n\t/**\n\t * Add an entry to the buffer.\n\t *\n\t * This method does not perform bounds checking, the caller should ensure no more entries are\n\t * added for each toPc than the maximum provided to the constructor.\n\t *\n\t * @param fromPc - The entry to add (the pc this step came from).\n\t * @param toPc   - The pc for which to add the entry.\n\t */\n\tpublic add(fromPc: number, toPc: number): void {\n\t\tconst length = this._buffer[toPc];\n\t\tconst offset = this._mapping[toPc];\n\t\tthis._buffer[toPc] += 1;\n\t\tthis._buffer[offset + length] = fromPc;\n\t}\n\n\t/**\n\t * Returns whether any entries have been added for the given pc.\n\t *\n\t * @param toPc - The pc to check entries for.\n\t */\n\tpublic has(toPc: number): boolean {\n\t\tconst length = this._buffer[toPc];\n\t\treturn length > 0;\n\t}\n\n\t/**\n\t * Iterates over the entries added for the given pc, (synchronously) invoking callback with the\n\t * value of each entry.\n\t *\n\t * @param toPc     - The entry whose values should be iterated over.\n\t * @param callback - Callback to invoke for each value.\n\t */\n\tpublic forEach(toPc: number, callback: (fromPc: number) => void): void {\n\t\tconst length = this._buffer[toPc];\n\t\tconst offset = this._mapping[toPc];\n\t\tfor (let i = offset; i < offset + length; ++i) {\n\t\t\tcallback(this._buffer[i]);\n\t\t}\n\t}\n}\n","/**\n * Represents a lazily-allocated Set-like datatype.\n *\n * Allocating actual sets during tracing is quite expensive, especially given that in the vast\n * majority of cases these sets will only consist of zero or one item. This simply represents those\n * cases as null or the item itself respectively, avoiding allocation until the set contains two or\n * more items.\n */\nexport type LazySet<T> = null | T | T[];\n\n/**\n * Returns the LazySet resulting from adding an item to the given LazySet.\n *\n * If item is already in set, always returns set.\n *\n * @param set            - The LazySet to add the item to\n * @param item           - The item to add\n * @param setIsImmutable - If left at false, when set is an array, item is pushed into the existing\n *                         array. If set to true, a new array will be allocated instead. This can be\n *                         used to prevent mutation of an existing set if you need to keep the\n *                         original value.\n */\nexport function addToLazySet<T>(\n\tset: LazySet<T>,\n\titem: T,\n\tsetIsImmutable: boolean = false\n): LazySet<T> {\n\tif (set === null) {\n\t\treturn item;\n\t}\n\tif (Array.isArray(set)) {\n\t\tif (set.indexOf(item) === -1) {\n\t\t\tif (setIsImmutable) {\n\t\t\t\tset = set.slice();\n\t\t\t}\n\t\t\tset.push(item);\n\t\t}\n\t\treturn set;\n\t}\n\tif (set === item) {\n\t\treturn set;\n\t}\n\treturn [set, item];\n}\n\n/**\n * Returns a LazySet representing the union of the given sets.\n *\n * @param set1            - First set\n * @param set2            - Second set\n * @param setIsImmutable - If left at false, when set1 is an array, items in set2 are pushed into\n *                         the existing array. If set to true, a new array will be allocated\n *                         instead. This can be used to prevent mutation of an existing set if you\n *                         need to keep the original value.\n */\nexport function mergeLazySets<T>(\n\tset1: LazySet<T>,\n\tset2: LazySet<T>,\n\tset1IsImmutable: boolean\n): LazySet<T> {\n\tif (set1 === null) {\n\t\treturn set2;\n\t}\n\tif (set2 === null) {\n\t\treturn set1;\n\t}\n\tif (Array.isArray(set2)) {\n\t\treturn set2.reduce(\n\t\t\t(set: LazySet<T>, item: T) => addToLazySet(set, item, set === set2),\n\t\t\tset1\n\t\t);\n\t}\n\treturn addToLazySet(set1, set2, set1IsImmutable);\n}\n","/**\n * A Trace represents the execution history of a Thread in terms of the records gathered. Only paths\n * that differ in terms of these records are preserved.\n *\n * Trace is never cyclic (i.e., a given Trace is never included in its prefixes, including,\n * recursively, the prefixes thereof).\n *\n * Trace instances are often reused and should therefore never be mutated after creation.\n */\nexport default class Trace<TRecord> {\n\tconstructor(\n\t\tpublic readonly prefixes: Trace<TRecord>[],\n\t\tpublic readonly record: TRecord | null\n\t) {}\n\n\t/**\n\t * Single instance used to represent the empty trace from which all programs start.\n\t */\n\tstatic EMPTY = new Trace<any>([], null);\n}\n","import FromBuffer from './FromBuffer';\nimport { LazySet, mergeLazySets } from './LazySet';\nimport Trace from './Trace';\n\n/**\n * Create a trace only when necessary.\n *\n * Not adding records to a single prefix can be represented by the prefix itself. Similarly, adding\n * a record to only the empty trace can omit the empty trace from the prefixes of the new trace.\n *\n * Finally, if the LazySet of prefixes was already an array, this reuses that array in the trace,\n * avoiding an extra allocation.\n *\n * @param prefixes - Non-empty LazySet of Trace instances, representing the unique ways to get here\n * @param record   - Optional record to include in the Trace\n */\nfunction createOrReuseTrace<TRecord>(\n\tprefixes: Exclude<LazySet<Trace<TRecord>>, null>,\n\trecord: TRecord | null\n): Trace<TRecord> {\n\tlet prefixesArray: Trace<TRecord>[];\n\tif (record === null) {\n\t\tif (!Array.isArray(prefixes)) {\n\t\t\treturn prefixes;\n\t\t}\n\t\tprefixesArray = prefixes;\n\t} else if (prefixes === Trace.EMPTY) {\n\t\t// No need to include empty prefixes on the new trace with a record\n\t\tprefixesArray = [];\n\t} else if (Array.isArray(prefixes)) {\n\t\tprefixesArray = prefixes;\n\t} else {\n\t\tprefixesArray = [prefixes];\n\t}\n\n\treturn new Trace(prefixesArray, record);\n}\n\n/**\n * Used to ensure that each instruction is visited only once per survivor, and to abort cyclic paths\n * so traces constructed never form cycles.\n */\nconst enum TracingState {\n\tNOT_VISITED,\n\tIN_CURRENT_PATH,\n\tDONE\n}\n\n/**\n * Handles updating Trace instances across each generation, while minimizing allocations.\n */\nexport default class Tracer<TRecord> {\n\tprivate readonly _stateByPc: TracingState[] = [];\n\tprivate readonly _prefixesByPc: LazySet<Trace<TRecord>>[] = [];\n\n\tconstructor(programLength: number) {\n\t\tfor (let i = 0; i < programLength; ++i) {\n\t\t\tthis._stateByPc.push(TracingState.NOT_VISITED);\n\t\t\tthis._prefixesByPc.push(null);\n\t\t}\n\t}\n\n\t/**\n\t * Determines traces for each entry in startingFromBuffer for pc, and adds them to prefixes,\n\t * returning the resulting LazySet.\n\t *\n\t * Steps taken by trace() after the first step use the fromByPc FromBuffer instead of the\n\t * startingFromBuffer. This supports the fact that the first step is always from a survivor, so\n\t * should be taken in the survivor from buffer, while the rest of the steps are within the\n\t * generation.\n\t */\n\tprivate mergeTraces(\n\t\tprefixes: LazySet<Trace<TRecord>>,\n\t\tpc: number,\n\t\tstartingFromBuffer: FromBuffer,\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\n\t\tfromByPc: FromBuffer,\n\t\trecordByPc: (TRecord | null)[]\n\t): LazySet<Trace<TRecord>> {\n\t\tlet isPrefixesReused = false;\n\t\tstartingFromBuffer.forEach(pc, fromPc => {\n\t\t\tconst traces = this.trace(fromPc, previousTraceBySurvivorPc, fromByPc, recordByPc);\n\t\t\tprefixes = mergeLazySets(prefixes, traces, isPrefixesReused);\n\t\t\tisPrefixesReused = prefixes === traces;\n\t\t});\n\t\treturn prefixes;\n\t}\n\n\t/**\n\t * Determines traces leading to pc, stepping through fromByPc and using incoming traces (i.e.,\n\t * from a previous generation) from previousTraceBySurvivorPc.\n\t *\n\t * To prevent allocations, traces are represented as a LazySet of their prefixes for as long as\n\t * possible, which usually means until a record has to be added.\n\t *\n\t * @param pc                        - The pc from which to trace\n\t * @param previousTraceBySurvivorPc - Incoming traces (built up in the previous generation)\n\t * @param fromByPc                  - The FromBuffer to trace through\n\t * @param recordByPc                - Records to include when a trace passes through the\n\t *                                    corresponding pc.\n\t */\n\tprivate trace(\n\t\tpc: number,\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\n\t\tfromByPc: FromBuffer,\n\t\trecordByPc: (TRecord | null)[]\n\t): LazySet<Trace<TRecord>> {\n\t\tconst state = this._stateByPc[pc];\n\t\tswitch (state) {\n\t\t\tcase TracingState.DONE:\n\t\t\t\treturn this._prefixesByPc[pc];\n\n\t\t\tcase TracingState.IN_CURRENT_PATH:\n\t\t\t\t// Trace is a cycle, ignore this path\n\t\t\t\treturn null;\n\t\t}\n\n\t\t// Mark state to detect cycles\n\t\tthis._stateByPc[pc] = TracingState.IN_CURRENT_PATH;\n\n\t\tlet prefixes: LazySet<Trace<TRecord>> = null;\n\t\tconst startingTrace = previousTraceBySurvivorPc[pc];\n\t\tif (startingTrace !== null) {\n\t\t\tprefixes = startingTrace;\n\t\t} else if (!fromByPc.has(pc)) {\n\t\t\tthrow new Error(`Trace without source at pc ${pc}`);\n\t\t}\n\t\tprefixes = this.mergeTraces(\n\t\t\tprefixes,\n\t\t\tpc,\n\t\t\tfromByPc,\n\t\t\tpreviousTraceBySurvivorPc,\n\t\t\tfromByPc,\n\t\t\trecordByPc\n\t\t);\n\n\t\tif (prefixes !== null) {\n\t\t\t// Valid prefixes found, check for records\n\t\t\tconst record = recordByPc[pc];\n\t\t\tif (record !== null) {\n\t\t\t\tprefixes = createOrReuseTrace(prefixes, record);\n\t\t\t}\n\t\t}\n\n\t\t// Add to cache and mark as complete\n\t\tthis._prefixesByPc[pc] = prefixes;\n\t\tthis._stateByPc[pc] = TracingState.DONE;\n\t\treturn prefixes;\n\t}\n\n\t/**\n\t * Populates newTraceBySurvivorPc with traces constructed from tracing for any survivor (i.e.,\n\t * those pcs having any entries in fromBySurvivorPc). Tracing takes the first step in\n\t * fromBySurvivorPc and then proceeds through fromByPc until complete, gathering unique traces\n\t * by combining incoming traces (from previousTraceBySurvivorPc) with new records (from\n\t * recordByPc) gathered along the way.\n\t *\n\t * @param previousTraceBySurvivorPc - Incoming traces (built up in the previous generation)\n\t * @param newTraceBySurvivorPc      - Array to populate with new traces (or null for\n\t *                                    non-survivor pcs)\n\t * @param fromBySurvivorPc          - The FromBuffer with the final steps for each thread (from\n\t *                                    within the generation to being a survivor)\n\t * @param fromByPc                  - The FromBuffer with all other steps taken within the\n\t *                                    generation.\n\t * @param recordByPc                - Records generated during the generation.\n\t */\n\tpublic buildSurvivorTraces(\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\n\t\tnewTraceBySurvivorPc: (Trace<TRecord> | null)[],\n\t\tfromBySurvivorPc: FromBuffer,\n\t\tfromByPc: FromBuffer,\n\t\trecordByPc: (TRecord | null)[]\n\t): void {\n\t\tfor (\n\t\t\tlet pc = 0, programLength = previousTraceBySurvivorPc.length;\n\t\t\tpc < programLength;\n\t\t\t++pc\n\t\t) {\n\t\t\tif (!fromBySurvivorPc.has(pc)) {\n\t\t\t\tnewTraceBySurvivorPc[pc] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Some cached results may depend on detected cycles. The points at which a cycle should\n\t\t\t// no longer be followed differ between survivors, so these cached results are not\n\t\t\t// transferrable between them. To work around this, we reset the tracing state and cache\n\t\t\t// before tracing each survivor, and later deduplicate results in Traces.getTraces().\n\t\t\tthis._prefixesByPc.fill(null);\n\t\t\tthis._stateByPc.fill(TracingState.NOT_VISITED);\n\t\t\tconst prefixes: LazySet<Trace<TRecord>> = this.mergeTraces(\n\t\t\t\tnull,\n\t\t\t\tpc,\n\t\t\t\tfromBySurvivorPc,\n\t\t\t\tpreviousTraceBySurvivorPc,\n\t\t\t\tfromByPc,\n\t\t\t\trecordByPc\n\t\t\t);\n\t\t\tif (prefixes === null) {\n\t\t\t\tthrow new Error(`No non-cyclic paths found to survivor ${pc}`);\n\t\t\t}\n\t\t\tnewTraceBySurvivorPc[pc] = createOrReuseTrace(prefixes, null);\n\t\t}\n\t\t// Free prefix sets for GC\n\t\tthis._prefixesByPc.fill(null);\n\t}\n}\n","import FromBuffer from './FromBuffer';\nimport { addToLazySet, LazySet } from './LazySet';\nimport ProgramInfo from './ProgramInfo';\nimport Trace from './Trace';\nimport Tracer from './Tracer';\n\n/**\n * Records information needed to build Trace instances after each generation concludes.\n */\nexport default class Traces<TRecord> {\n\t/**\n\t * Incoming steps (in terms of the pc these originated from by target pc), for steps within the\n\t * current generation.\n\t */\n\tprivate readonly _fromByPc: FromBuffer;\n\n\t/**\n\t * Incoming steps (in terms of the pc these originated from by target pc), for steps that lead\n\t * to the next generation.\n\t */\n\tprivate readonly _fromBySurvivorPc: FromBuffer;\n\n\t/**\n\t * Records generated, by pc, in the current generation\n\t */\n\tprivate readonly _recordByPc: (TRecord | null)[] = [];\n\n\t/**\n\t * Traces for anything that survived until the start of the generation, updated when the current\n\t * generation ends. Swaps with _nextTraceBySurvivorPc after each generation in order to minimize\n\t * allocations.\n\t */\n\tprivate _traceBySurvivorPc: (Trace<TRecord> | null)[] = [];\n\n\t/**\n\t * Array in which to build traces for the next generation when the current one ends. Swaps with\n\t * _traceBySurvivorPc after each generation in order to minimize allocations.\n\t */\n\tprivate _nextTraceBySurvivorPc: (Trace<TRecord> | null)[] = [];\n\n\t/**\n\t * Helper used for updating traces between generations.\n\t */\n\tprivate readonly _tracer: Tracer<TRecord>;\n\n\tconstructor(programInfo: ProgramInfo) {\n\t\tthis._fromByPc = new FromBuffer(programInfo.maxFromByPc);\n\t\tthis._fromBySurvivorPc = new FromBuffer(programInfo.maxSurvivorFromByPc);\n\t\tthis._tracer = new Tracer(programInfo.programLength);\n\t\tfor (let i = 0; i < programInfo.programLength; ++i) {\n\t\t\tthis._recordByPc.push(null);\n\t\t\tthis._traceBySurvivorPc.push(null);\n\t\t\tthis._nextTraceBySurvivorPc.push(null);\n\t\t}\n\n\t\tthis._traceBySurvivorPc[0] = Trace.EMPTY;\n\t}\n\n\t/**\n\t * Clear the instance after each generation or for a new run of the VM.\n\t *\n\t * @param clearSurvivors - Set to true to clear survivor traces when resetting for a new run.\n\t *                         Set to false when moving to the next generation to preserve these.\n\t */\n\tpublic reset(clearSurvivors: boolean): void {\n\t\tthis._fromByPc.clear();\n\t\tthis._fromBySurvivorPc.clear();\n\n\t\tthis._recordByPc.fill(null);\n\n\t\tif (clearSurvivors) {\n\t\t\tthis._traceBySurvivorPc.fill(null);\n\t\t\tthis._nextTraceBySurvivorPc.fill(null);\n\t\t\tthis._traceBySurvivorPc[0] = Trace.EMPTY;\n\t\t}\n\t}\n\n\t/**\n\t * Add a record for the current generation\n\t *\n\t * @param pc     - The pc of the record instruction this record originates from\n\t * @param record - The data to record\n\t */\n\tpublic record(pc: number, record: TRecord): void {\n\t\tthis._recordByPc[pc] = record;\n\t}\n\n\t/**\n\t * Returns whether the given instruction has already been visited during the current generation.\n\t *\n\t * This is determined by it having incoming entries in the corresponding FromBuffer, or by it\n\t * having an incoming trace from the previous generation.\n\t *\n\t * @param pc The pc to check.\n\t */\n\tpublic has(pc: number): boolean {\n\t\treturn this._fromByPc.has(pc) || this._traceBySurvivorPc[pc] !== null;\n\t}\n\n\t/**\n\t * Record the given step within the current generation.\n\t *\n\t * @param fromPc - Origin of the step\n\t * @param toPc   - Target of the step\n\t */\n\tpublic add(fromPc: number, toPc: number): void {\n\t\tthis._fromByPc.add(fromPc, toPc);\n\t}\n\n\t/**\n\t * Returns whether the given instruction has been stepped to for the next generation.\n\t *\n\t * This is determined by it having incoming entries in the corresponding FromBuffer.\n\t *\n\t * @param pc The pc to check.\n\t */\n\tpublic hasSurvivor(pc: number): boolean {\n\t\treturn this._fromBySurvivorPc.has(pc);\n\t}\n\n\t/**\n\t * Record the given step from the current generation to the next.\n\t *\n\t * @param fromPc - Origin of the step\n\t * @param toPc   - Target of the step\n\t */\n\tpublic addSurvivor(fromPc: number, toPc: number): void {\n\t\tthis._fromBySurvivorPc.add(fromPc, toPc);\n\t}\n\n\t/**\n\t * Builds traces for each survivor after a generation ends.\n\t *\n\t * Swaps the _traceBySurvivorPc and _nextTraceBySurvivorPc arrays afterwards to avoid\n\t * allocations.\n\t */\n\tpublic buildSurvivorTraces(): void {\n\t\tconst previousTraceBySurvivorPc = this._traceBySurvivorPc;\n\t\tthis._tracer.buildSurvivorTraces(\n\t\t\tpreviousTraceBySurvivorPc,\n\t\t\tthis._nextTraceBySurvivorPc,\n\t\t\tthis._fromBySurvivorPc,\n\t\t\tthis._fromByPc,\n\t\t\tthis._recordByPc\n\t\t);\n\t\t// Swap arrays\n\t\tthis._traceBySurvivorPc = this._nextTraceBySurvivorPc;\n\t\tthis._nextTraceBySurvivorPc = previousTraceBySurvivorPc;\n\t}\n\n\t/**\n\t * Returns unique traces for all threads that reached accept after all input has been processed.\n\t *\n\t * Should be called after the last generation finishes.\n\t *\n\t * @param acceptedPcs - The pcs for which to compute traces. These should all have survived the\n\t *                      last generation.\n\t */\n\tpublic getTraces(acceptedPcs: number[]): Trace<TRecord>[] {\n\t\tconst traces = acceptedPcs.reduce(\n\t\t\t(traces: LazySet<Trace<TRecord>>, pc: number) =>\n\t\t\t\taddToLazySet(traces, this._traceBySurvivorPc[pc]!),\n\t\t\tnull\n\t\t);\n\t\tif (traces === null) {\n\t\t\treturn [];\n\t\t}\n\t\treturn Array.isArray(traces) ? traces : [traces];\n\t}\n}\n","import Generation from './Generation';\nimport ProgramInfo from './ProgramInfo';\nimport Trace from './Trace';\nimport Traces from './Traces';\n\n/**\n * Responsible for tracking all execution state for a running VM.\n *\n * This manages scheduling of threads for the current and next generation using two instances of\n * Generation. It also handles tracking steps for the current generation and updating Trace\n * instances for any survivors (i.e., threads that made it to the next generation) using a Traces\n * instance.\n *\n * Note that threads are not represented directly. Generation only schedules program counter (pc)\n * values with a corresponding badness. Traces only tracks steps taken through the program. At the\n * end of all input, we're only interested in the unique paths taken to get there in terms of the\n * records collected along the way.\n */\nexport default class Scheduler<TRecord> {\n\tprivate _currentGeneration: Generation;\n\tprivate _nextGeneration: Generation;\n\n\t// Trace data for the current generation\n\tprivate readonly _traces: Traces<TRecord>;\n\n\t// PCs of accepted threads in the current generation\n\tprivate readonly _acceptedPcs: number[] = [];\n\n\tconstructor(programInfo: ProgramInfo) {\n\t\tthis._currentGeneration = new Generation(programInfo.programLength);\n\t\tthis._nextGeneration = new Generation(programInfo.programLength);\n\t\tthis._traces = new Traces(programInfo);\n\t}\n\n\t/**\n\t * Clears all information for a new run of the program.\n\t */\n\tpublic reset(): void {\n\t\tthis._currentGeneration.reset();\n\t\tthis._currentGeneration.add(0, 0);\n\n\t\tthis._acceptedPcs.length = 0;\n\t\tthis._traces.reset(true);\n\t}\n\n\t/**\n\t * Get the pc for the next thread to execute, or null if there are no more threads to run in the\n\t * current generation.\n\t */\n\tpublic getNextThreadPc(): number | null {\n\t\treturn this._currentGeneration.getNextPc();\n\t}\n\n\t/**\n\t * Step the thread forward, updating traces and scheduling the new thread in the current\n\t * generation.\n\t *\n\t * @param fromPc       - The current pc being executed\n\t * @param toPc         - The pc at which to continue\n\t * @param badnessDelta - The amount by which to increase badness for toPc\n\t */\n\tpublic step(fromPc: number, toPc: number, badnessDelta: number) {\n\t\tconst alreadyScheduled = this._traces.has(toPc);\n\t\tthis._traces.add(fromPc, toPc);\n\n\t\tconst badness = this._currentGeneration.getBadness(fromPc) + badnessDelta;\n\t\tif (alreadyScheduled) {\n\t\t\tthis._currentGeneration.reschedule(toPc, badness);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule the next step\n\t\tthis._currentGeneration.add(toPc, badness);\n\t}\n\n\t/**\n\t * Step the thread forward, updating traces and scheduling the new thread in the next\n\t * generation.\n\t *\n\t * @param fromPc       - The current pc being executed\n\t * @param toPc         - The pc at which to continue\n\t */\n\tpublic stepToNextGeneration(fromPc: number, toPc: number) {\n\t\tconst alreadyScheduled = this._traces.hasSurvivor(toPc);\n\t\tthis._traces.addSurvivor(fromPc, toPc);\n\n\t\tconst badness = this._currentGeneration.getBadness(fromPc);\n\t\tif (alreadyScheduled) {\n\t\t\tthis._nextGeneration.reschedule(toPc, badness);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._nextGeneration.add(toPc, badness);\n\t}\n\n\t/**\n\t * Marks the thread ending at pc as successful (i.e., it executed an accept instruction when all\n\t * input has been processed). The trace for pc will be included in the result returned from\n\t * VM.execute().\n\t *\n\t * @param pc - The current pc being executed (corresponding to an accept instruction)\n\t */\n\tpublic accept(pc: number): void {\n\t\tthis._acceptedPcs.push(pc);\n\t\tthis._traces.addSurvivor(pc, pc);\n\t}\n\n\t/**\n\t * Marks the thread ending at pc as failed, i.e., it was stopped from continuing execution. This\n\t * could happen in the following cases:\n\t *\n\t * - it executed an accept instruction while not all input has been processed\n\t * - it executed a fail instruction (for which the callback returned true if there was one)\n\t * - it executed a test instruction for which the callback returned false\n\t * - it executed a jump instruction with no targets\n\t *\n\t * This does not currently do anything, but could be used to determine an explanation why input\n\t * was not accepted by the VM in a future version.\n\t *\n\t * @param _pc - The current pc being executed (corresponding to one of the cases mentioned)\n\t */\n\tpublic fail(_pc: number): void {\n\t\t// TODO: track failures as the combination of input x instruction?\n\t}\n\n\t/**\n\t * Adds a record for traces that include the pc.\n\t *\n\t * @param pc     - The pc for which to add the record, corresponding to a record instruction.\n\t * @param record - The record to add.\n\t */\n\tpublic record(pc: number, record: TRecord): void {\n\t\tthis._traces.record(pc, record);\n\t}\n\n\t/**\n\t * Updates traces for survivors and switches to the next generation. To be called when there are\n\t * no more threads scheduled in the current generation (i.e., getNextThreadPc returns null).\n\t */\n\tpublic nextGeneration(): void {\n\t\tthis._traces.buildSurvivorTraces();\n\n\t\tthis._traces.reset(false);\n\n\t\tconst gen = this._currentGeneration;\n\t\tgen.reset();\n\t\tthis._currentGeneration = this._nextGeneration;\n\t\tthis._nextGeneration = gen;\n\t}\n\n\t/**\n\t * Returns the unique traces for all accepted pcs. To be called after the generation for the\n\t * last input item has completed.\n\t */\n\tpublic getAcceptingTraces(): Trace<TRecord>[] {\n\t\treturn this._traces.getTraces(this._acceptedPcs);\n\t}\n}\n","import { Instruction, FailFunc, RecordFunc, TestFunc, Operation } from './Instruction';\nimport ProgramInfo from './ProgramInfo';\nimport Result from './Result';\nimport Scheduler from './Scheduler';\n\n/**\n * A virtual machine to execute whynot programs.\n *\n * @public\n */\nexport default class VM<TInput, TRecord, TOptions = void> {\n\tprivate readonly _program: Instruction<TInput, TRecord, TOptions>[];\n\tprivate readonly _programInfo: ProgramInfo;\n\tprivate readonly _schedulers: Scheduler<TRecord>[] = [];\n\n\t/**\n\t * @param program - The program to run, as created by the Assembler\n\t */\n\tconstructor(program: Instruction<TInput, TRecord, TOptions>[]) {\n\t\tthis._program = program;\n\t\tthis._programInfo = ProgramInfo.fromProgram(program);\n\t\tthis._schedulers.push(new Scheduler(this._programInfo));\n\t}\n\n\t/**\n\t * Executes the program in the VM with the given input stream.\n\t *\n\t * @param input   - An array of input items.\n\t * @param options - Optional object passed to all instruction callbacks.\n\t *\n\t * @returns Result of the execution, containing all Traces that lead to acceptance of the input\n\t *          (if any)\n\t */\n\texecute(input: TInput[], options?: TOptions): Result<TRecord> {\n\t\tconst scheduler = this._schedulers.pop() || new Scheduler(this._programInfo);\n\n\t\t// Add initial thread\n\t\tscheduler.reset();\n\n\t\tconst inputLength = input.length;\n\t\tlet inputIndex = -1;\n\t\tlet inputItem: TInput | null;\n\t\tdo {\n\t\t\t// Get next thread to execute\n\t\t\tlet pc = scheduler.getNextThreadPc();\n\t\t\tif (pc === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Read next input item\n\t\t\t++inputIndex;\n\t\t\tinputItem = inputIndex >= inputLength ? null : input[inputIndex];\n\n\t\t\twhile (pc !== null) {\n\t\t\t\tconst instruction: Instruction<TInput, TRecord, TOptions> = this._program[pc];\n\n\t\t\t\tswitch (instruction.op) {\n\t\t\t\t\tcase Operation.ACCEPT:\n\t\t\t\t\t\t// Only accept if we reached the end of the input\n\t\t\t\t\t\tif (inputItem === null) {\n\t\t\t\t\t\t\tscheduler.accept(pc);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscheduler.fail(pc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Operation.FAIL: {\n\t\t\t\t\t\t// Is the failure conditional?\n\t\t\t\t\t\tconst func = instruction.func as FailFunc<TOptions> | null;\n\t\t\t\t\t\tconst isFailingCondition = func === null || func(options);\n\t\t\t\t\t\tif (isFailingCondition) {\n\t\t\t\t\t\t\t// Branch is forbidden, end the thread\n\t\t\t\t\t\t\tscheduler.fail(pc);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Condition failed, continue at next instruction\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase Operation.BAD:\n\t\t\t\t\t\t// Continue at next pc with added badness\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, instruction.data as number);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Operation.TEST: {\n\t\t\t\t\t\t// Fail if out of input\n\t\t\t\t\t\tif (inputItem === null) {\n\t\t\t\t\t\t\tscheduler.fail(pc);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fail if input does not match\n\t\t\t\t\t\tconst func = instruction.func as TestFunc<TInput, TOptions>;\n\t\t\t\t\t\tconst isInputAccepted = func(inputItem, instruction.data, options);\n\t\t\t\t\t\tif (!isInputAccepted) {\n\t\t\t\t\t\t\tscheduler.fail(pc);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Continue in next generation, preserving badness\n\t\t\t\t\t\tscheduler.stepToNextGeneration(pc, pc + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase Operation.JUMP: {\n\t\t\t\t\t\t// Spawn new threads for all targets\n\t\t\t\t\t\tconst targetPcs = instruction.data as number[];\n\t\t\t\t\t\tconst numTargets = targetPcs.length;\n\t\t\t\t\t\tif (numTargets === 0) {\n\t\t\t\t\t\t\tscheduler.fail(pc);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < numTargets; ++i) {\n\t\t\t\t\t\t\tscheduler.step(pc, targetPcs[i], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase Operation.RECORD: {\n\t\t\t\t\t\t// Invoke record callback\n\t\t\t\t\t\tconst func = instruction.func as RecordFunc<TRecord, TOptions>;\n\t\t\t\t\t\tconst record = func(instruction.data, inputIndex, options);\n\t\t\t\t\t\tif (record !== null && record !== undefined) {\n\t\t\t\t\t\t\tscheduler.record(pc, record);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Continue with next instruction\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Next thread\n\t\t\t\tpc = scheduler.getNextThreadPc();\n\t\t\t}\n\n\t\t\t// End current Generation and continue with the next\n\t\t\tscheduler.nextGeneration();\n\t\t} while (inputItem !== null);\n\n\t\tconst result = new Result(scheduler.getAcceptingTraces());\n\n\t\t// Clear and recycle the scheduler\n\t\tscheduler.reset();\n\t\tthis._schedulers.push(scheduler);\n\n\t\treturn result;\n\t}\n}\n","import Assembler from './Assembler';\nimport VM from './VM';\n\nexport { default as Assembler } from './Assembler';\nexport { default as VM } from './VM';\n\n/**\n * Convenience helper function that creates a new VM using the specified callback for compilation.\n *\n * @public\n *\n * @param compile - Function used to compile the program, invoked with an Assembler as the only\n *                  parameter.\n *\n * @returns VM running the compiled program\n */\nexport function compileVM<TInput, TRecord = void, TOptions = void>(\n\tcompile: (assembler: Assembler<TInput, TRecord, TOptions>) => void\n): VM<TInput, TRecord, TOptions> {\n\tconst assembler = new Assembler<TInput, TRecord, TOptions>();\n\tcompile(assembler);\n\treturn new VM<TInput, TRecord, TOptions>(assembler.program);\n}\n\nexport default { Assembler, VM, compileVM };\n"],"names":["addInstruction","program","op","func","data","instruction","push","defaultRecorder","_inputIndex","Assembler","[object Object]","this","matcher","undefined","targets","recorder","cost","predicate","ProgramInfo","programLength","maxFromByPc","maxSurvivorFromByPc","length","forEach","_","pc","Error","targetPc","i","Result","acceptingTraces","success","MAX_BADNESS","Generation","_numScheduledPcs","_nextThread","_scheduledPcs","Uint16Array","_badnessByPc","Uint8Array","badness","insertionIndex","pcs","badnessByPc","first","low","high","mid","findInsertionIndex","copyWithin","maxBadness","Math","max","existingThreadIndex","indexOf","add","fill","FromBuffer","_mapping","offset","_buffer","fromPc","toPc","callback","addToLazySet","set","item","setIsImmutable","Array","isArray","slice","Trace","prefixes","record","createOrReuseTrace","prefixesArray","EMPTY","Tracer","_stateByPc","_prefixesByPc","startingFromBuffer","previousTraceBySurvivorPc","fromByPc","recordByPc","isPrefixesReused","traces","trace","set1","set2","set1IsImmutable","reduce","startingTrace","has","mergeTraces","newTraceBySurvivorPc","fromBySurvivorPc","Traces","programInfo","_recordByPc","_traceBySurvivorPc","_nextTraceBySurvivorPc","_fromByPc","_fromBySurvivorPc","_tracer","clearSurvivors","clear","buildSurvivorTraces","acceptedPcs","Scheduler","_acceptedPcs","_currentGeneration","_nextGeneration","_traces","reset","getNextPc","badnessDelta","alreadyScheduled","getBadness","reschedule","hasSurvivor","addSurvivor","_pc","gen","getTraces","VM","_schedulers","_program","_programInfo","fromProgram","input","options","scheduler","pop","inputLength","inputItem","inputIndex","getNextThreadPc","accept","fail","step","stepToNextGeneration","targetPcs","numTargets","nextGeneration","result","getAcceptingTraces","compileVM","compile","assembler","index"],"mappings":"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"}