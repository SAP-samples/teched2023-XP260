{"version":3,"file":"prsc.esm.js","sources":["../src/parser-combinators.ts","../src/streaming.ts"],"sourcesContent":["/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\nfunction lengthFromCodePoint(cp: number): number {\n\treturn cp > 0xffff ? 2 : 1;\n}\n\n/**\n * Creates a Parser that skips the next code point if the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * To match a sequence of code points, consider using `codepoints` instead.\n *\n * @public\n *\n * @param isMatch  - callback called with the next codepoint, should return whether that matches\n * @param expected - expected strings to return if the codepoint does not match\n */\nexport function codepoint(\n\tisMatch: (codepoint: number) => boolean,\n\texpected: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp === undefined || !isMatch(cp)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset + lengthFromCodePoint(cp));\n\t};\n}\n\n/**\n * Creates a Parser that skips code points while the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * This acts like `starConsumed(codepoint(isMatch, []))` if expected is not set, or as\n * `plusConsumed(codepoint(isMatch, expected))` if it is, but is much more efficient than either of\n * those combinations.\n *\n * @public\n *\n * @param isMatch  - callback called for each codepoint, should return whether that matches\n * @param expected - expected strings to return if the first codepoint does not match\n */\nexport function codepoints(\n\tisMatch: (codepoint: number) => boolean,\n\texpected?: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst startOffset = offset;\n\t\twhile (true) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!isMatch(cp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += cp > 0xffff ? 2 : 1;\n\t\t}\n\t\tif (expected !== undefined && offset === startOffset) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * Use `recognize` if you need the character that was matched.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(\n\tfirstCodePoint: number,\n\tlastCodePoint: number,\n\texpected?: string[]\n): Parser<void> {\n\treturn codepoint(\n\t\t(cp) => firstCodePoint <= cp && cp <= lastCodePoint,\n\t\texpected || [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]\n\t);\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += lengthFromCodePoint(cp);\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n * @param fatal    - Whether the error returned when the filter rejects should be fatal\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[],\n\tfatal?: boolean\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected, fatal);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers  - Parsers to attempt to apply\n * @param expected - Overrides the expected value used if none of the inner parsers match\n */\nexport function or<T>(parsers: Parser<T>[], expected?: string[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset && expected === undefined) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\texpected = expected || lastError?.expected || [];\n\t\tif (lastError) {\n\t\t\tlastError.expected = expected;\n\t\t}\n\t\treturn lastError || error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function starConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn (input, offset) => {\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn ok(nextOffset);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, returning a tuple of the\n * corresponding values if all of them accept.\n *\n * This can be slightly less efficient than nesting `then` and its variations, but may be a lot more\n * readable. If you don't care about any of the values produced, consider using `sequenceConsumed`\n * instead.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequence<Ts extends unknown[]>(\n\t...parsers: { [key in keyof Ts]: Parser<Ts[key]> }\n): Parser<Ts> {\n\treturn (input, offset) => {\n\t\tconst values: Ts = [] as unknown[] as Ts;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t\tvalues.push(res.value);\n\t\t}\n\t\treturn okWithValue(offset, values);\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, discarding all of the values\n * produced.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequenceConsumed(...parsers: Parser<unknown>[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached. The parser is required to match at least once, so an initial failure is\n * returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plusConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn then(parser, starConsumed(parser), second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * When using this in combination with `star` or `plus`, consider using `starConsumed` or\n * `plusConsumed` instead for efficiency.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a parser that looks at a single codepoint to determine which parser to invoke. Can be\n * used as an alternative to large `or` parsers if looking ahead can narrow down the options.\n *\n * Can optionally look ahead further than the current codepoint, which is useful when nesting\n * several `dispatch` parsers.\n *\n * @public\n *\n * @param mapping     - Object mapping code points to parsers\n * @param otherwise   - Parser to use when the code point is not found in the mapping, or undefined\n *                      to reject in that situation.\n * @param extraOffset - How far ahead to look for the codepoint, defaults to 0\n * @param expected    - Expected values for parse errors generated when there is no codepoint or\n *                      when the codepoint is not in the mapping and there is no `otherwise` parser\n */\nexport function dispatch<T>(\n\tmapping: { [codepoint: number]: Parser<T> },\n\totherwise: Parser<T> | undefined,\n\textraOffset: number = 0,\n\texpected: string[] = []\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst cp = input.codePointAt(offset + extraOffset);\n\t\tif (cp === undefined) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\tconst parser = mapping[cp];\n\t\tif (parser === undefined) {\n\t\t\tif (otherwise === undefined) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn otherwise(input, offset);\n\t\t}\n\t\treturn parser(input, offset);\n\t};\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { end, ok, Parser, ParseResult } from './parser-combinators';\n\n/**\n * Helper to collect both the yielded values and the returned value from a generator.\n *\n * @public\n *\n * @param gen - Generator to collect from\n */\nexport function collect<T, R>(gen: Generator<T, R>): [T[], R] {\n\tconst values: T[] = [];\n\tlet it = gen.next();\n\twhile (!it.done) {\n\t\tvalues.push(it.value);\n\t\tit = gen.next();\n\t}\n\treturn [values, it.value];\n}\n\n/**\n * A StreamingParser is similar to a Parser, but instead of returning a value when parsing is\n * complete it can parse incrementally and yield values as they are produced. The generator returns\n * a ParseResult when iteration is done which indicates whether parsing was successful.\n *\n * @public\n */\nexport type StreamingParser<T> = (\n\tinput: string,\n\toffset: number\n) => Generator<T, ParseResult<unknown>>;\n\n/**\n * Creates a StreamingParser which applies the given Parser and yields the value produced if it\n * matches.\n *\n * @public\n *\n * @param parser - The Parser to apply\n */\nexport function streaming<T>(parser: Parser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = parser(input, offset);\n\t\tif (res.success) {\n\t\t\tyield res.value;\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a StreamingParser which applies the given two StreamingParsers in sequence.\n *\n * Unlike `then`, this does not combine values using a function, but instead simply yields the\n * values produced by both parsers as they produce them.\n *\n * @public\n *\n * @param parser1 - First StreamingParser to apply\n * @param parser2 - StreamingParser to apply if the first one is successful\n */\nexport function streamingThen<T, U>(\n\tparser1: StreamingParser<T>,\n\tparser2: StreamingParser<U>\n): StreamingParser<T | U> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res1 = yield* parser1(input, offset);\n\t\tif (!res1.success) {\n\t\t\treturn res1;\n\t\t}\n\t\treturn yield* parser2(input, res1.offset);\n\t};\n}\n\n/**\n * Creates a StreamingParser which discards undefined values yielded by the given StreamingParser.\n *\n * @public\n *\n * @param parser - The StreamingParser to filter\n */\nexport function streamingFilterUndefined<T>(parser: StreamingParser<T | void>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst gen = parser(input, offset);\n\t\tlet it = gen.next();\n\t\twhile (!it.done) {\n\t\t\tconst value = it.value;\n\t\t\tif (value !== undefined) {\n\t\t\t\tyield value;\n\t\t\t}\n\t\t\tit = gen.next();\n\t\t}\n\t\treturn it.value;\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given StreamingParser zero or more times in\n * sequence. Values produced during each iteration are only yielded whenever the inner parser\n * matches successfully.\n *\n * @public\n *\n * @param parser - StreamingParser to apply repeatedly\n */\nexport function streamingStar<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\twhile (true) {\n\t\t\tconst [values, result] = collect(parser(input, offset));\n\t\t\tif (!result.success) {\n\t\t\t\tif (result.fatal) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\n\t\t\tyield* values;\n\n\t\t\tif (offset === result.offset) {\n\t\t\t\t// Did not advance\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\t\t\toffset = result.offset;\n\t\t}\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given parser optionally. It only yields the\n * values produced by the inner parser if it matches successfully, and does not yield anything\n * otherwise.\n *\n * @public\n *\n * @param parser - StreamingParser to attempt to apply\n */\nexport function streamingOptional<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst [values, result] = collect(parser(input, offset));\n\t\tif (!result.success) {\n\t\t\tif (result.fatal) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn ok(offset);\n\t\t}\n\n\t\tyield* values;\n\n\t\treturn result;\n\t};\n}\n\n/**\n * Creates a StreamingParser that applies the given parser and directly yields values produced by\n * it, and then only succeeds if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - StreamingParser to apply\n */\nexport function streamingComplete<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = yield* parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn end(input, res.offset);\n\t};\n}\n"],"names":["okWithValue","offset","value","success","ok","undefined","error","expected","fatal","token","input","offsetAfter","length","slice","lengthFromCodePoint","cp","codepoint","isMatch","codePointAt","codepoints","startOffset","range","firstCodePoint","lastCodePoint","String","fromCodePoint","skipChars","nCodepoints","i","map","parser","res","consume","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","push","starConsumed","filterUndefined","vs","v","then","parser1","parser2","join","r1","r2","sequence","values","sequenceConsumed","plus","first","x","y","second","plusConsumed","preceded","before","followed","after","delimited","open","inner","close","cutAfterOpen","cut","recognize","peek","not","except","match","dispatch","mapping","otherwise","extraOffset","start","_input","end","complete","collect","gen","it","next","done","streaming","streamingThen","res1","streamingFilterUndefined","streamingStar","result","streamingOptional","streamingComplete"],"mappings":"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"}